<div style="color:blue" align=center>Android开发学习（10）WebView访问网页</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
        <div class="markdown_views"><p>在不少的应用中，如果要快速搭建自己的应用，H5也是个不错的选择，在App端，保留H5的入口，也就是展示网页的入口就可以，本篇文章就和大家一起做一个展示网页的入口。 <br>
先看我们实现的结果： <br>
<img src="19173536770270" alt="web-view" title=""></p>



<h1 id="webview">WebView</h1>

<p>使用H5实现的功能能够在不升级App的情况下动态更新，而且可以在Android或iOS的App上同时运行，节约了成本，提高了开发效率。  <br>
原理：其实就是Java代码和JavaScript之间的调用。</p>



<h2 id="常用方法">常用方法</h2>

<p>loadUrl <br>
加载界面，其次还有LoadData和LoadDataWithBase方法</p>



<pre class="prettyprint"><code class=" hljs avrasm">    //加载assets目录下的test<span class="hljs-preprocessor">.html</span>文件
    webView<span class="hljs-preprocessor">.loadUrl</span>(<span class="hljs-string">"file:///android_asset/test.html"</span>)<span class="hljs-comment">;</span>
    //加载网络资源(注意要加上网络权限)
    webView<span class="hljs-preprocessor">.loadUrl</span>(<span class="hljs-string">"http://blog.csdn.net"</span>)<span class="hljs-comment">;</span></code></pre>

<p>setWebViewClient（如果用户设置了WebViewClient，则在点击新的链接以后就不会跳转到系统浏览器了，而是在本WebView中显示。注意：并不需要覆盖 shouldOverrideUrlLoading 方法，同样可以实现所有的链接都在 WebView 中打开。） <br>
WebViewClient主要用来辅助WebView处理各种通知、请求等事件，通过setWebViewClient方法设置。以下是它的几种常见用法： <br>
实现对网页中超链接的拦截(比如如果是其他网页的主页，则直接拦截转到百度主页)：  <br>
当点击页面中的链接后，会在WebView加载URL前回调shouldOverrideUrlLoading(WebView view, String url)方法，一般点击一个链接此方法调用一次。</p>



<pre class="prettyprint"><code class=" hljs java">         webView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient(){
        <span class="hljs-annotation">@Override</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span>(WebView view, String url) {
            <span class="hljs-keyword">if</span>(<span class="hljs-string">"http://www.jikedaohang.com/"</span>.equals(url))                   {
                view.loadUrl(<span class="hljs-string">"https://www.baidu.com/"</span>);
            }

                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
                    }
                });</code></pre>

<p>关于shouldOverrideUrlLoading返回值的误区：网上很多解释是return true代表在本WebView中打开链接，return false代表调用系统浏览器打开链接。其实只要设置了WebViewClient，则就不会调用系统浏览器。  <br>
那么shouldOverrideUrlLoading的返回值到底代表什么呢？return true，则在打开新的url时WebView就不会再加载这个url了，所有处理都需要在WebView中操作，包含加载；return false，则系统就认为上层没有做处理，接下来还是会继续加载这个url的；默认return false。具体的区别展示如下：  <br>
加载百度主页，设置WebViewClient后，重写shouldOverrideUrlLoading(WebView view, String url)方法，返回false的点击后正常跳转）返回true的点击无反应，如果希望能够跳转，则需要我们自己进行处理  <br>
还有一点需要注意的是，如果我们拦截了某个url，那么return false 和 return true区别不大，所以一般建议 return false。 <br>
加载网页时替换某个资源（比如在加载一个网页时，需要加载一个logo图片，而我们想要替换这个logo图片，用我们assets目录下的一张图片替代）  <br>
我们知道我们在加载一个网页的同时也会加载js,css,图片等资源，所以会多次调用shouldInterceptRequest方法，我们可以在shouldInterceptRequest中进行图片替换。  <br>
注意：shouldInterceptRequest有两个重载：  <br>
public WebResourceResponse shouldInterceptRequest (WebView view, String url) 【已过时】  <br>
public WebResourceResponse shouldInterceptRequest (WebView view, WebResourceRequest request)  <br>
这两种方法主要是第二个参数的不同，WebResourceRequest 将能够获取更多的信息，提供了getUrl(),getMethod,getRequestHeaders等方法。这里主要是为了展示效果，使用了第一种回调方法。实现方法如下：</p>



<pre class="prettyprint"><code class=" hljs java">        mWebView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient(){
                    <span class="hljs-annotation">@Override</span>
                    <span class="hljs-keyword">public</span> WebResourceResponse <span class="hljs-title">shouldInterceptRequest</span>(WebView view, String url) {
                        WebResourceResponse response = <span class="hljs-keyword">null</span>;
                        <span class="hljs-keyword">if</span> (url.contains(<span class="hljs-string">"logo"</span>)) {
                            <span class="hljs-keyword">try</span> {
                                InputStream logo = getAssets().open(<span class="hljs-string">"logo.png"</span>);
                                response = <span class="hljs-keyword">new</span> WebResourceResponse(<span class="hljs-string">"image/png"</span>, <span class="hljs-string">"UTF-8"</span>, logo);
                            } <span class="hljs-keyword">catch</span> (IOException e) {
                                e.printStackTrace();
                            }
                        }
                        <span class="hljs-keyword">return</span> response;
                    }
                });</code></pre>

<p>设置开始加载网页、加载完成、加载错误时处理</p>



<pre class="prettyprint"><code class=" hljs r">        webView.setWebViewClient(new WebViewClient() {    

            @Override  
            public void onPageStarted(WebView view, String url, Bitmap favicon) {  
                super.onPageStarted(view, url, favicon);  
                // 开始加载网页时处理 如：显示<span class="hljs-string">"加载提示"</span> 的加载对话框  
                <span class="hljs-keyword">...</span>
            }  

            @Override  
            public void onPageFinished(WebView view, String url) {  
                super.onPageFinished(view, url);  
                // 网页加载完成时处理  如：让 加载对话框 消失  
                <span class="hljs-keyword">...</span>
            }  

            @Override  
            public void onReceivedError(WebView view, int errorCode, String description, String failingUrl) {  
                super.onReceivedError(view, errorCode, description, failingUrl);  
                // 加载网页失败时处理 如：提示失败，或显示新的界面
                <span class="hljs-keyword">...</span>
            }    
        });  
</code></pre>

<p>处理https请求，为WebView处理ssl证书设置WebView默认是不处理https请求的，需要在WebViewClient子类中重写父类的onReceivedSslError函数</p>



<pre class="prettyprint"><code class=" hljs java">        webView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient() {    

            <span class="hljs-annotation">@Override</span>  
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onReceivedSslError</span>(WebView view, SslErrorHandler handler, SslError error) {  
                handler.proceed();  <span class="hljs-comment">// 接受信任所有网站的证书  </span>
                <span class="hljs-comment">// handler.cancel();   // 默认操作 不处理  </span>
                <span class="hljs-comment">// handler.handleMessage(null);  // 可做其他处理  </span>
            }   
        });   </code></pre>

<p>setWebChromeClient <br>
WebChromeClient主要用来辅助WebView处理JavaScript的对话框、网站图标、网站标题以及网页加载进度等。通过WebView的setWebChromeClient()方法设置。 <br>
显示页面加载进度在WebChromeClient子类中重写父类的onProgressChanged函数，progress表示当前页面加载的进度，为1至100的整数</p>



<pre class="prettyprint"><code class=" hljs r">        webView.setWebChromeClient(new WebChromeClient() {    

            public void onProgressChanged(WebView view, int progress) {    
                setTitle(<span class="hljs-string">"页面加载中，请稍候..."</span> + progress + <span class="hljs-string">"%"</span>);    
                setProgress(progress * <span class="hljs-number">100</span>);    

                <span class="hljs-keyword">if</span> (progress == <span class="hljs-number">100</span>) {    
                    //<span class="hljs-keyword">...</span> 
                }    
            }    
        });  </code></pre>

<p>加快HTML网页加载完成速度（默认情况html代码下载到WebView后，webkit开始解析网页各个节点，发现有外部样式文件或者外部脚本文件时，会异步发起网络请求下载文件，但如果在这之前也有解析到image节点，那势必也会发起网络请求下载相应的图片。在网络情况较差的情况下，过多的网络请求就会造成带宽紧张，影响到css或js文件加载完成的时间，造成页面空白loading过久。解决的方法就是告诉WebView先不要自动加载图片，等页面finish后再发起图片加载。） <br>
首先在WebView初始化时添加如下代码</p>



<pre class="prettyprint"><code class=" hljs avrasm">        if(Build<span class="hljs-preprocessor">.VERSION</span><span class="hljs-preprocessor">.SDK</span>_INT &gt;= <span class="hljs-number">19</span>) {  
        <span class="hljs-comment">/*对系统API在19以上的版本作了兼容。因为4.4以上系统在onPageFinished时再恢复图片加载时,如果存在多张图片引用的是相同的src时，会只有一个image标签得到加载，因而对于这样的系统我们就先直接加载。*/</span>        webView<span class="hljs-preprocessor">.getSettings</span>()<span class="hljs-preprocessor">.setLoadsImagesAutomatically</span>(true)<span class="hljs-comment">;  </span>
            } else {  
                webView<span class="hljs-preprocessor">.getSettings</span>()<span class="hljs-preprocessor">.setLoadsImagesAutomatically</span>(false)<span class="hljs-comment">;  </span>
            }  </code></pre>

<p>在WebView的WebViewClient子类中重写onPageFinished()方法添加如下代码： </p>



<pre class="prettyprint"><code class=" hljs java">         <span class="hljs-annotation">@Override</span>  
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPageFinished</span>(WebView view, String url) {  
            <span class="hljs-keyword">if</span>(!webView.getSettings().getLoadsImagesAutomatically()) {  
                webView.getSettings().setLoadsImagesAutomatically(<span class="hljs-keyword">true</span>);  
            }  
        }  </code></pre>

<p>setDownloadListener <br>
通常webview渲染的界面中含有可以下载文件的链接，点击该链接后，应该开始执行下载的操作并保存文件到本地中。</p>

<p>创建DownloadListener</p>



<pre class="prettyprint"><code class=" hljs axapta">        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDownloadListenter</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">DownloadListener</span>{</span>
              @Override
              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onDownloadStart(String url, String userAgent,String contentDisposition, String mimetype, <span class="hljs-keyword">long</span> contentLength) {
                  <span class="hljs-comment">//下载任务...，主要有两种方式</span>
                  <span class="hljs-comment">//（1）自定义下载任务</span>
                  <span class="hljs-comment">//（2）调用系统的download的模块</span>
                  Uri uri = Uri.parse(url);
                  Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW, uri);
                  startActivity(intent);
              }
        }</code></pre>

<p>给webview加入监听</p>



<pre class="prettyprint"><code class=" hljs cs">        webview.setDownloadListener(<span class="hljs-keyword">new</span> MyDownloadListenter());</code></pre>

<p>goBack() <br>
返回上一浏览页面，通过重写onKeyDown方法实现点击返回键返回上一浏览页面而非退出程序</p>



<pre class="prettyprint"><code class=" hljs cs">    <span class="hljs-keyword">public</span> boolean <span class="hljs-title">onKeyDown</span>(<span class="hljs-keyword">int</span> keyCode, KeyEvent <span class="hljs-keyword">event</span>) {  
    <span class="hljs-comment">//其中webView.canGoBack()在webView含有一个可后退的浏览记录时返回true</span>

            <span class="hljs-keyword">if</span> ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) {       
                webView.goBack();       
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;       
            }       
            <span class="hljs-keyword">return</span> super.onKeyDown(keyCode, <span class="hljs-keyword">event</span>);       
        }
    }</code></pre>



<h2 id="websettings配置">WebSettings配置</h2>

<p>获取WebSettings对象</p>



<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">WebSettings webSettings </span>=<span class="hljs-string"> webView.getSettings();</span></code></pre>

<p>常用设置方法 <br>
支持js</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setJavaScriptEnabled(<span class="hljs-literal">true</span>);</code></pre>

<p>设置缓存方式，主要有以下几种：  <br>
LOAD_CACHE_ONLY: 不使用网络，只读取本地缓存数据。  <br>
LOAD_DEFAULT: 根据cache-control决定是否从网络上取数据。  <br>
LOAD_CACHE_NORMAL: API level 17中已经废弃, 从API level 11开始作用同LOAD_DEFAULT模式。  <br>
LOAD_NO_CACHE: 不使用缓存，只从网络获取数据。  <br>
LOAD_CACHE_ELSE_NETWORK：只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.setCacheMode</span>(WebSettings<span class="hljs-preprocessor">.LOAD</span>_NO_CACHE)<span class="hljs-comment">;</span></code></pre>

<p>开启DOM storage API功能（HTML5 提供的一种标准的接口，主要将键值对存储在本地，在页面加载完毕后可以通过 javascript 来操作这些数据。）</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setDomStorageEnabled(<span class="hljs-literal">true</span>);</code></pre>

<p>设置数据库缓存路径</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.setDatabasePath</span>(cacheDirPath)<span class="hljs-comment">;</span></code></pre>

<p>设置Application Caches缓存目录</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.setAppCachePath</span>(cacheDirPath)<span class="hljs-comment">;</span></code></pre>

<p>设置默认编码</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.setDefaultTextEncodingName</span>(“utf-<span class="hljs-number">8</span>”)<span class="hljs-comment">;</span></code></pre>

<p>将图片调整到适合webview的大小</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setUseWideViewPort(<span class="hljs-literal">false</span>);</code></pre>

<p>支持缩放</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setSupportZoom(<span class="hljs-literal">true</span>);</code></pre>

<p>支持内容重新布局</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.setLayoutAlgorithm</span>(WebSettings<span class="hljs-preprocessor">.LayoutAlgorithm</span><span class="hljs-preprocessor">.SINGLE</span>_COLUMN)<span class="hljs-comment">;</span></code></pre>

<p>多窗口</p>



<pre class="prettyprint"><code class=" hljs avrasm">        settings<span class="hljs-preprocessor">.supportMultipleWindows</span>()<span class="hljs-comment">;</span></code></pre>

<p>设置可以访问文件</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setAllowFileAccess(<span class="hljs-literal">true</span>);</code></pre>

<p>当webview调用requestFocus时为webview设置节点</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setNeedInitialFocus(<span class="hljs-literal">true</span>);</code></pre>

<p>设置支持缩放</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setBuiltInZoomControls(<span class="hljs-literal">true</span>);</code></pre>

<p>支持通过JS打开新窗口</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setJavaScriptCanOpenWindowsAutomatically(<span class="hljs-literal">true</span>);</code></pre>

<p>缩放至屏幕的大小</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setLoadWithOverviewMode(<span class="hljs-literal">true</span>);</code></pre>

<p>支持自动加载图片</p>



<pre class="prettyprint"><code class=" hljs bash">        settings.setLoadsImagesAutomatically(<span class="hljs-literal">true</span>);</code></pre>



<h2 id="webviewclient-的回调">WebViewClient 的回调</h2>

<p>WebViewClient主要用来辅助WebView处理各种通知、请求等事件，通过setWebViewClient方法设置。</p>

<p>更新历史记录</p>



<pre class="prettyprint"><code class=" hljs vbnet">    doUpdateVisitedHistory(WebView view, <span class="hljs-built_in">String</span> url, <span class="hljs-built_in">boolean</span> isReload)</code></pre>

<p>应用程序重新请求网页数据</p>



<pre class="prettyprint"><code class=" hljs mathematica">    onFormResubmission(WebView view, <span class="hljs-keyword">Message</span> dontResend, <span class="hljs-keyword">Message</span> resend)</code></pre>

<p>在加载页面资源时会调用，每一个资源（比如图片）的加载都会调用一次。</p>



<pre class="prettyprint"><code class=" hljs javascript">    onLoadResource(WebView view, <span class="hljs-built_in">String</span> url)</code></pre>

<p>开始载入页面调用，通常我们可以在这设定一个loading的页面，告诉用户程序在等待网络响应。</p>



<pre class="prettyprint"><code class=" hljs javascript">    onPageStarted(WebView view, <span class="hljs-built_in">String</span> url, Bitmap favicon)</code></pre>

<p>在页面加载结束时调用。同样道理，我们知道一个页面载入完成，于是我们可以关闭loading 条，切换程序动作。</p>



<pre class="prettyprint"><code class=" hljs javascript">    onPageFinished(WebView view, <span class="hljs-built_in">String</span> url)</code></pre>

<p>报告错误信息</p>



<pre class="prettyprint"><code class=" hljs vbscript">    onReceivedError(WebView view, <span class="hljs-built_in">int</span> errorCode, <span class="hljs-built_in">String</span> description, <span class="hljs-built_in">String</span> failingUrl)</code></pre>

<p>获取返回信息授权请求</p>



<pre class="prettyprint"><code class=" hljs javascript">    onReceivedHttpAuthRequest(WebView view, HttpAuthHandler handler, <span class="hljs-built_in">String</span> host,<span class="hljs-built_in">String</span> realm)</code></pre>

<p>重写此方法可以让webview处理https请求。</p>



<pre class="prettyprint"><code class=" hljs lua">    onReceivedSslError(WebView view, SslErrorHandler handler, SslError <span class="hljs-built_in">error</span>)</code></pre>

<p>WebView发生改变时调用</p>



<pre class="prettyprint"><code class=" hljs cs">    onScaleChanged(WebView view, <span class="hljs-keyword">float</span> oldScale, <span class="hljs-keyword">float</span> newScale)</code></pre>

<p>Key事件未被加载时调用</p>



<pre class="prettyprint"><code class=" hljs cs">    onUnhandledKeyEvent(WebView view, KeyEvent <span class="hljs-keyword">event</span>)</code></pre>

<p>重写此方法才能够处理在浏览器中的按键事件。</p>



<pre class="prettyprint"><code class=" hljs cs">    shouldOverrideKeyEvent(WebView view, KeyEvent <span class="hljs-keyword">event</span>)</code></pre>

<p>在网页跳转时调用，这个函数我们可以做很多操作，比如我们读取到某些特殊的URL，于是就可以不打开地址，取消这个操作，进行预先定义的其他操作，这对一个程序是非常必要的。</p>



<pre class="prettyprint"><code class=" hljs javascript">    shouldOverrideUrlLoading(WebView view, <span class="hljs-built_in">String</span> url)</code></pre>

<p>在加载某个网页的资源的时候多次调用（已过时）</p>



<pre class="prettyprint"><code class=" hljs javascript">    shouldInterceptRequest(WebView view, <span class="hljs-built_in">String</span> url)</code></pre>

<p>在加载某个网页的资源的时候多次调用</p>



<pre class="prettyprint"><code class=" hljs vbscript">    shouldInterceptRequest(WebView view, WebResourceRequest <span class="hljs-built_in">request</span>)</code></pre>

<p>注意： <br>
shouldOverrideUrlLoading在网页跳转的时候调用，且一般每跳转一次只调用一次。  <br>
shouldInterceptRequest只要是网页加载的过程中均会调用，资源加载的时候都会回调该方法，会多次调用。</p>



<h2 id="webchoromeclient的回调">WebChoromeClient的回调</h2>

<p>WebChromeClient主要用来辅助WebView处理Javascript的对话框、网站图标、网站标题以及网页加载进度等。通过WebView的setWebChromeClient()方法设置。</p>

<p>监听网页加载进度</p>



<pre class="prettyprint"><code class=" hljs cs">    onProgressChanged(WebView view, <span class="hljs-keyword">int</span> newProgress)</code></pre>

<p>监听网页标题 : 比如百度页面的标题是“百度一下，你就知道”</p>



<pre class="prettyprint"><code class=" hljs javascript">    onReceivedTitle(WebView view, <span class="hljs-built_in">String</span> title)</code></pre>

<p>监听网页图标</p>



<pre class="prettyprint"><code class=" hljs scss">    <span class="hljs-function">onReceivedIcon(WebView view, Bitmap icon)</span></code></pre>



<h2 id="java和javascript互调">Java和JavaScript互调</h2>

<p>为方便展示，使用addJavascriptInterface方式实现与本地js交互（存在漏洞）。也可通过其他方式实现，比如拦截ur进行参数解析l等。 <br>
Java调JS</p>

<p>首先是JS的一段代码：</p>



<pre class="prettyprint"><code class=" hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">javaCallJs</span><span class="hljs-params">(arg)</span>{</span>
         document.getElementById(<span class="hljs-string">"content"</span>).innerHTML =
             (<span class="hljs-string">"欢迎："</span>+arg );
    }</code></pre>

<p>然后是在java中调用JS中的方法</p>



<pre class="prettyprint"><code class=" hljs avrasm">webView<span class="hljs-preprocessor">.loadUrl</span>(<span class="hljs-string">"javascript:javaCallJs("</span>+<span class="hljs-string">"'"</span>+name+<span class="hljs-string">"'"</span>+<span class="hljs-string">")"</span>)<span class="hljs-comment">;</span></code></pre>

<p>以上代码就是调用了JS中一个叫javaCallJs(arg)的方法，并传入了一个name参数。 <br>
JS调java <br>
配置Javascript接口</p>



<pre class="prettyprint"><code class=" hljs cs">webView.addJavascriptInterface(<span class="hljs-keyword">new</span> JSInterface (),<span class="hljs-string">"Android"</span>);</code></pre>

<p>实现Javascript接口类</p>



<pre class="prettyprint"><code class=" hljs haskell"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-type">JSInterface</span> {
    @<span class="hljs-type">JavascriptInterface</span>
     public void showToast<span class="hljs-container">(<span class="hljs-type">String</span> <span class="hljs-title">arg</span>)</span>{
                   <span class="hljs-type">Toast</span>.makeText<span class="hljs-container">(<span class="hljs-type">MainActivity</span>.<span class="hljs-title">this</span>,<span class="hljs-title">arg</span>,<span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span>)</span>.show<span class="hljs-container">()</span>;
     }
}</span></code></pre>

<p>JS中调用java代码</p>



<pre class="prettyprint"><code class=" hljs ocaml">&lt;input <span class="hljs-class"><span class="hljs-keyword">type</span>=</span><span class="hljs-string">"button"</span> <span class="hljs-keyword">value</span>=<span class="hljs-string">"点击Android被调用"</span> onclick=<span class="hljs-string">"window.Android.showToast('JS中传来的参数')"</span>/&gt;</code></pre>

<p>window.Android.showToast(‘JS中传来的参数’)”中的”Android”即addJavascriptInterface（）中指定的，并且JS向Java传递了参数，类型为String。而showToast(String arg)会以Toast的形式弹出此参数。 <br>
代码非常简单，并且加了注释，直接看代码就可以了。 <br>
首先是本地的JavaAndJavaScriptCall.html文件，放在asstes目录下</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">http-equiv</span>=<span class="hljs-value">"Content-Type"</span> <span class="hljs-attribute">content</span>=<span class="hljs-value">"text/html;charset=UTF-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"text/javascript"</span>&gt;</span><span class="javascript">

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">javaCallJs</span><span class="hljs-params">(arg)</span>{</span>
         document.getElementById(<span class="hljs-string">"content"</span>).innerHTML =
             (<span class="hljs-string">"欢迎："</span>+arg );
    }

    </span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"content"</span>&gt;</span> 请在上方输入您的用户名<span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">input</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"button"</span> <span class="hljs-attribute">value</span>=<span class="hljs-value">"点击Android被调用"</span> <span class="hljs-attribute">onclick</span>=<span class="hljs-value">"window.Android.showToast('JS中传来的参数')"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span></code></pre>

<p>javaCallJs是java调用JS的方法，showToast方法是JS调用java的方法</p>

<p>接下来是布局文件，activity_main.xml</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout</span> <span class="hljs-attribute">xmlns:android</span>=<span class="hljs-value">"http://schemas.android.com/apk/res/android"</span>
    <span class="hljs-attribute">xmlns:tools</span>=<span class="hljs-value">"http://schemas.android.com/tools"</span>
    <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/ll_root"</span>
    <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"match_parent"</span>
    <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"vertical"</span>
    <span class="hljs-attribute">tools:context</span>=<span class="hljs-value">".MainActivity"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">LinearLayout
</span>        <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"match_parent"</span>
        <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
        <span class="hljs-attribute">android:orientation</span>=<span class="hljs-value">"horizontal"</span>
        <span class="hljs-attribute">android:padding</span>=<span class="hljs-value">"20dp"</span>
        <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#000088"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">EditText
</span>            <span class="hljs-attribute">android:id</span>=<span class="hljs-value">"@+id/et_user"</span>
            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"0dp"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:hint</span>=<span class="hljs-value">"输入WebView中要显示的用户名"</span>
            <span class="hljs-attribute">android:background</span>=<span class="hljs-value">"#008800"</span>
            <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span>
            <span class="hljs-attribute">android:layout_weight</span>=<span class="hljs-value">"1"</span>/&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">Button
</span>            <span class="hljs-attribute">android:layout_width</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_height</span>=<span class="hljs-value">"wrap_content"</span>
            <span class="hljs-attribute">android:layout_marginLeft</span>=<span class="hljs-value">"40dp"</span>
            <span class="hljs-attribute">android:layout_marginRight</span>=<span class="hljs-value">"20dp"</span>
            <span class="hljs-attribute">android:textSize</span>=<span class="hljs-value">"16sp"</span>
            <span class="hljs-attribute">android:text</span>=<span class="hljs-value">"确定"</span>
            <span class="hljs-attribute">android:onClick</span>=<span class="hljs-value">"click"</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span>

<span class="hljs-tag">&lt;/<span class="hljs-title">LinearLayout</span>&gt;</span></code></pre>

<p>很简单，就是一个输入框和一个确定按钮，点击按钮会调用JS中的方法。</p>

<p>MainActivity</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> com.wangjian.webviewdemo;

<span class="hljs-keyword">import</span> android.annotation.SuppressLint;
<span class="hljs-keyword">import</span> android.support.v7.app.AppCompatActivity;
<span class="hljs-keyword">import</span> android.os.Bundle;
<span class="hljs-keyword">import</span> android.view.View;
<span class="hljs-keyword">import</span> android.view.ViewGroup;
<span class="hljs-keyword">import</span> android.webkit.JavascriptInterface;
<span class="hljs-keyword">import</span> android.webkit.WebSettings;
<span class="hljs-keyword">import</span> android.webkit.WebView;
<span class="hljs-keyword">import</span> android.webkit.WebViewClient;
<span class="hljs-keyword">import</span> android.widget.EditText;
<span class="hljs-keyword">import</span> android.widget.LinearLayout;
<span class="hljs-keyword">import</span> android.widget.Toast;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> {</span>

    <span class="hljs-keyword">private</span> WebView webView;
    <span class="hljs-keyword">private</span> LinearLayout ll_root;
    <span class="hljs-keyword">private</span> EditText et_user;

    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {
        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ll_root = (LinearLayout) findViewById(R.id.ll_root);
        et_user = (EditText) findViewById(R.id.et_user);
        initWebView();
    }

    <span class="hljs-comment">//初始化WebView</span>

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initWebView</span>() {
        <span class="hljs-comment">//动态创建一个WebView对象并添加到LinearLayout中</span>
        webView = <span class="hljs-keyword">new</span> WebView(getApplication());
        LinearLayout.LayoutParams params = <span class="hljs-keyword">new</span> LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT);
        webView.setLayoutParams(params);
        ll_root.addView(webView);
        <span class="hljs-comment">//不跳转到其他浏览器</span>
        webView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span>(WebView view, String url) {
                view.loadUrl(url);
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
            }
        });
        WebSettings settings = webView.getSettings();
        <span class="hljs-comment">//支持JS</span>
        settings.setJavaScriptEnabled(<span class="hljs-keyword">true</span>);
        <span class="hljs-comment">//加载本地html文件</span>
        webView.loadUrl(<span class="hljs-string">"file:///android_asset/JavaAndJavaScriptCall.html"</span>);
        webView.addJavascriptInterface(<span class="hljs-keyword">new</span> JSInterface(),<span class="hljs-string">"Android"</span>);
    }

    <span class="hljs-comment">//按钮的点击事件</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">click</span>(View view){
        <span class="hljs-comment">//java调用JS方法</span>
        webView.loadUrl(<span class="hljs-string">"javascript:javaCallJs("</span> + <span class="hljs-string">"'"</span> + et_user.getText().toString()+<span class="hljs-string">"'"</span>+<span class="hljs-string">")"</span>);
    }

    <span class="hljs-comment">//在页面销毁的时候将webView移除</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span>() {
        <span class="hljs-keyword">super</span>.onDestroy();
        ll_root.removeView(webView);
        webView.stopLoading();
        webView.removeAllViews();
        webView.destroy();
        webView = <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JSInterface</span> {</span>
        <span class="hljs-comment">//JS需要调用的方法</span>
        <span class="hljs-annotation">@JavascriptInterface</span>
        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showToast</span>(String arg){
            Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>,arg,Toast.LENGTH_SHORT).show();
        }
    }
}</code></pre>



<h2 id="需要注意的地方">需要注意的地方</h2>

<p>参考链接：<a href="http://blog.csdn.net/hytfly/article/details/48489251" target="_blank">安卓webview的一些坑</a> <br>
    webView.addJavascriptInterface()方法在API 17之前有一些漏洞（有兴趣的可以参考本篇文章，WebView 远程代码执行漏洞浅析），所以在API 17以后，需要在JavaScript接口类的方法加上@JavascriptInterface注解。 <br>
    仔细看的话你会发现我们上面的WebView对象并不是直接写在布局文件中的，而是通过一个LinearLayout容器，使用addview(webview)动态向里面添加的。另外需要注意创建webview需要使用applicationContext而不是activity的context，销毁时不再占有activity对象，最后离开的时候需要及时销毁webview，onDestory()中应该先从LinearLayout中remove掉webview,再调用webview.removeAllViews();webview.destory(); <br>
    如果想要webView在产生OOM的时候不影响主进程，可以另开一个进程，在androidmanifest.xml的activity标签里加上Android:process属性就可以了。</p>

<pre><code>在activity被杀死之后，依然保持webView的状态，方便用户下次打开的时候可以回到之前的状态。webview支持saveState(bundle)和restoreState(bundle)方法。
</code></pre>

<p>保存状态</p>



<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>  
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSaveInstanceState</span>(Bundle outState) {  
    <span class="hljs-keyword">super</span>.onSaveInstanceState(outState);  
    wv.saveState(outState);  
    Log.e(TAG, <span class="hljs-string">"save state..."</span>);  
}  </code></pre>

<p>恢复状态（在activity的onCreate(bundle savedInstanceState)里）</p>



<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">null</span><span class="hljs-subst">!=</span>savedInstanceState){  
    wv<span class="hljs-built_in">.</span>restoreState(savedInstanceState);  
    <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">"restore state"</span>);  
}<span class="hljs-keyword">else</span>{  
    wv<span class="hljs-built_in">.</span>loadUrl(<span class="hljs-string">"http://3g.cn"</span>);  
}  </code></pre>

<p>其他一些常见问题：</p>

<ul>
<li><p>WebViewClient.onPageFinished()。  <br>
你永远无法确定当WebView调用这个方法的时候，网页内容是否真的加载完毕了。当前正在加载的网页产生跳转的时候这个方法可能会被多次调用，StackOverflow上有比较具体的解释（How to listen for a Webview finishing loading a URL in Android?）， 但其中列举的解决方法并不完美。所以当你的WebView需要加载各种各样的网页并且需要在页面加载完成时采取一些操作的话，可能WebChromeClient.onProgressChanged()比WebViewClient.onPageFinished()都要靠谱一些。</p></li>
<li><p>WebView后台耗电问题。  <br>
当你的程序调用了WebView加载网页，WebView会自己开启一些线程（？），如果你没有正确地将WebView销毁的话，这些残余的线程（？）会一直在后台运行，由此导致你的应用程序耗电量居高不下。对此我采用的处理方式比较偷懒，简单又粗暴（不建议），即在Activity.onDestroy()中直接调用System.exit(0)，使得应用程序完全被移出虚拟机，这样就不会有任何问题了。</p></li>
<li><p>切换WebView闪屏问题。  <br>
如果你需要在同一个ViewGroup中来回切换不同的WebView（包含了不同的网页内容）的话，你就会发现闪屏是不可避免的。这应该是Android硬件加速的Bug，如果关闭硬件加速这种情况会好很多，但无法获得很好的浏览体验，你会感觉网页滑动的时候一卡一卡的，不跟手。</p></li>
<li><p>在某些手机上，Webview有视频时，activity销毁后，视频资源没有被销毁，甚至还能听到在后台播放。即便是像刚才那样各种销毁webview也无济于事，解决办法：在onDestory之前修改url为空地址。</p></li>
<li><p>WebView硬件加速导致页面渲染闪烁问题  <br>
关于Android硬件加速 开始于Android 3.0 (API level 11),开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个副作用就是容易会出现页面加载白块同时界面闪烁现象。解决这个问题的方法是设置WebView暂时关闭硬件加速 代码如下： </p></li>
</ul>



<pre class="prettyprint"><code class=" hljs avrasm">    if (Build<span class="hljs-preprocessor">.VERSION</span><span class="hljs-preprocessor">.SDK</span>_INT &gt;= Build<span class="hljs-preprocessor">.VERSION</span>_CODES<span class="hljs-preprocessor">.HONEYCOMB</span>) { 
    webview<span class="hljs-preprocessor">.setLayerType</span>(View<span class="hljs-preprocessor">.LAYER</span>_TYPE_SOFTWARE, null)<span class="hljs-comment">; </span>
    }</code></pre>

<ul>
<li>ERR_CACHE_MISS <br>
webview加载网页时提示NET::ERR_CACHE_MISS的错误，原因很简单，就是没有添加网络访问的权限，在AndroidManifest.xml中加下就好了，如下：</li>
</ul>



<pre class="prettyprint"><code class=" hljs xml">    <span class="hljs-tag">&lt;/<span class="hljs-title">application</span>&gt;</span>  
        <span class="hljs-tag">&lt;<span class="hljs-title">uses-permission</span> <span class="hljs-attribute">android:name</span>=<span class="hljs-value">"android.permission.INTERNET"</span> /&gt;</span>  </code></pre>

<ul>
<li>ERR_UNKNOWN_URL_SCHEME </li>
</ul>

<p>在WebView中如果使用到安全性较高的网页，需要添加以下代码，否则操作系统会将URL拦截，导致你打不开页面。</p>



<pre class="prettyprint"><code class=" hljs java">    mWebView.setWebViewClient(<span class="hljs-keyword">new</span> WebViewClient(){  
            <span class="hljs-annotation">@Override</span>  
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldOverrideUrlLoading</span>(WebView view, String url) {  
                <span class="hljs-keyword">if</span>( url.startsWith(<span class="hljs-string">"http:"</span>) || url.startsWith(<span class="hljs-string">"https:"</span>) ) {  
                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  
                }  
       <span class="hljs-keyword">try</span>{
                Intent intent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_VIEW, Uri.parse(url));  
                startActivity( intent );  
       }<span class="hljs-keyword">catch</span>(Exception e){}
                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  
            }  
        });  
</code></pre>

<p>这里要注意的是上面需要加下try catch,因为你传过来的url并不一定是合法的。有可能是打开本地app的url，如果你没有安装，是会导致崩溃的。</p>

<p>相关项目已发布git，各位可自行下载：</p>

<p><a href="https://github.com/xvshu/xvshu_android_test/">git_xvshu_android_test</a></p></div>
        <script>
            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        </script>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/77093345'>原文链接</a>