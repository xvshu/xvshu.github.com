<div style="color:blue" align=center>JAVA并发编程线程与进程的由来（一）</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp; &nbsp; 在学习Java编程之初，我们就接触过Java线程，当时敲过代码也总结过，但是现在看来还是有点缺陷，并没有联系线程的由来来说明问题，只是简单的介绍了什么是进程，什么是线程，以及它们之间的关系-《<a target="_blank" target="_blank" href="http://blog.csdn.net/hejingyuan6/article/details/22093367">Java-线程</a>》。今天我们从进程和线程的由来来补充一下之前的总结。<br><br>参考：<a target="_blank" target="_blank" href="http://www.cnblogs.com/dolphin0520/p/3910667.html">http://www.cnblogs.com/dolphin0520/p/3910667.html</a><br><br><br></span><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">一.操作系统中为什么会出现进程？</span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><span style="font-family:KaiTi_GB2312;font-size:18px;">说起进程的由来，我们需要从操作系统的发展历史谈起。<br><br><strong>最初计算机：</strong><br><br>&nbsp; &nbsp; 也许在今天，我们无法想象在很多年以前计算机是什么样子。我们现在可以用计算机来做很多事情：办公、娱乐、上网，但是在计算机刚出现的时候，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成是很耗时间和人力成本的。<br>&nbsp; &nbsp; 在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就在等待。显然这样效率和很低下，因为很多时候，计算机处于等待用户输入的状态。<br><br><strong>解决效率低下问题-批处理操作：</strong><br><br>&nbsp; &nbsp; 那么能不能把一系列需要操作的指令预先写下来，形成一个清单，然后一次性交给计算机，计算机不断地去读取指令来进行相应的操作？就这样，批处理操作系统诞生了。用户可以将需要执行的多个程序写在磁带上，然后交由计算机去读取并逐个地执行这些程序，并将输出结果写到另一个磁带上。<br><br><strong>虽然批处理操作系统的诞生极大地提高了任务处理的便捷性，但是仍然存在一个很大的问题：</strong><br><br>&nbsp; &nbsp; 假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。人们于是想，能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？<br>&nbsp; &nbsp; 但是这样就有一个问题，原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。而如果想要任务A执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？<br><br><strong>进程：</strong><br><br>&nbsp; &nbsp; 这个时候人们就发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂时时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。<br>&nbsp; &nbsp; 这就是并发，能够让操作系统从宏观上看起来同一个时间段有多个任务在执行。换句话说，进程让操作系统的并发成为了可能。<br>&nbsp; &nbsp; 注意，虽然并发从宏观上看有多个任务在执行，但是事实上，任一个具体的时刻，只有一个任务在占用CPU资源（当然是对于单核CPU来说的）。<br><br></span><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">二.为什么会出现线程？</span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><strong>实时性要求：</strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><strong><br></strong></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp; &nbsp; 在出现了进程之后，操作系统的性能得到了大大的提升。虽然进程的出现解决了操作系统的并发问题，但是人们仍然不满足，人们逐渐对实时性有了要求。因为一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><strong><span style="font-family:KaiTi_GB2312;font-size:18px;">例子：</span></strong></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp; &nbsp; 比如对于一个监控系统来说，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取图像数据，还要处理人们的交互操作。如果某一个时刻该系统正在与服务器通信获取图像数据，而用户又在监控系统上点击了某个按钮，那么该系统就要等待获取完图像数据之后才能处理用户的操作，如果获取图像数据需要耗费10s，那么用户就只有一直在等待。显然，对于这样的系统，人们是无法满足的。<br><br><strong>线程：</strong><br><br>&nbsp; &nbsp; 那么可不可以将这些子任务分开执行呢？即在系统获取图像数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取图像数据。<br>&nbsp; &nbsp; 这样人们就发明了线程，让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务，这样在用户点击按钮的时候，就可以暂停获取图像数据的线程，让UI线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。<br>&nbsp; &nbsp; 换句话说，进程让操作系统的并发性成为可能，而线程让进程的内部并发成为可能。<br>但是要注意，一个进程虽然包括多个线程，但是这些线程是共同享有进程占有的资源和地址空间的。进程是操作系统进行资源分配的基本单位（各个进程间互不干扰），而线程是操作系统进行调度的基本单位（线程间的互相切换）。<br><br><br></span><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">三.多线程并发</span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp; &nbsp; 由于多个线程是共同占有所属进程的资源和地址空间的，那么就会存在一个问题：<br>&nbsp; &nbsp; 如果多个线程要同时访问某个资源，怎么处理？同步问题<br>&nbsp; &nbsp; 现在很多时候都采用多线程编程，那么是不是多线程的性能一定就由于单线程呢？<br>&nbsp; &nbsp; 不一定，要看具体的任务以及计算机的配置。比如说：<br>&nbsp; &nbsp; 对于单核CPU，如果是CPU密集型任务，如解压文件，多线程的性能反而不如单线程性能，因为解压文件需要一直占用CPU资源，如果采用多线程，线程切换导致的开销反而会让性能下降。<br>&nbsp; &nbsp; 但是对于比如交互类型的任务，肯定是需要使用多线程的。<br>&nbsp; &nbsp; 而对于多核CPU，对于解压文件来说，多线程肯定优于单线程，因为多个线程能够更加充分利用每个核的资源。<br>&nbsp; &nbsp; 虽然多线程能够提升程序性能，但是相对于单线程来说，它的编程要复杂地多，要考虑线程安全问题。因此，在实际编程过程中，要根据实际情况具体选择。<br><br><strong>附：</strong><br><br>&nbsp; &nbsp; 进程并发：操作系统已经帮我们处理完成<br>&nbsp; &nbsp; 线程并发：Java采用的是单线程编程模型，即在我们自己的程序中如果没有主动创建线程的话，只会创建一个线程，通常称为主线程。但是要注意，虽然只有一个线程来执行任务，不代表JVM（在Java中，一个应用程序对应着一个JVM实例（也有地方称为JVM进程））中只有一个线程，JVM实例在创建的时候，同时会创建很多其他的线程（比如垃圾收集器线程）。<br><br><br></span><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">总结：</span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp; &nbsp; 结合以上的解释，进程和线程的出现，一句话概括：为了充分利用CPU资源。那么结合计算机我们再来理解一下，进程--我们计算机中运行的各个应用程序，线程--每个应用程序内部的子任务。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/46722779'>原文链接</a>