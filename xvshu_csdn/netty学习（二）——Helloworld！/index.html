<div style="color:blue" align=center>netty学习（二）——Helloworld！</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p><span style="font-size:18px;">在认识完基本概念后，我们开始进行我们自己的hello world 简单范例，以此来揭开netty的第一层面纱：</span></p><h1><span style="font-size:18px;">1，maven</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 首先我们需要引入netty的jar包，依赖如下：</span></p><p><pre code_snippet_id="1761093" snippet_file_name="blog_20160713_1_8954933" name="code" class="html"><span style="font-size:18px;">&lt;dependency&gt;
	&lt;groupId&gt;io.netty&lt;/groupId&gt;
	&lt;artifactId&gt;netty&lt;/artifactId&gt;
	&lt;version&gt;3.10.5.Final&lt;/version&gt;
&lt;/dependency&gt;</span></pre><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">2，服务端</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 服务端的简单逻辑就是监听8000端口，注册消息处理方法，在获取到客户端链接的方法中打印 hello world</span></p><p><span style="font-size:18px;"><br></span></p><p><pre code_snippet_id="1761093" snippet_file_name="blog_20160713_2_9620807" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.one;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.*;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

/**
 * Netty 服务端
 * Created by xvshu on 2016/7/13.
 */
public class HelloServer {
    public static void main(String args[]) {

        // Server服务启动器

        ServerBootstrap bootstrap = new ServerBootstrap(

                new NioServerSocketChannelFactory(

                        Executors.newCachedThreadPool(),

                        Executors.newCachedThreadPool()));

        // 设置一个处理客户端消息和各种消息事件的类(Handler)

        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {

            @Override

            public ChannelPipeline getPipeline() throws Exception {

                return Channels.pipeline(new HelloServerHandler());

            }

        });

        // 开放8000端口供客户端访问。

        bootstrap.bind(new InetSocketAddress(8000));

    }



    private static class HelloServerHandler extends SimpleChannelHandler {



        /**

         * 当有客户端绑定到服务端的时候触发，打印&quot;Hello world, I'm server.&quot;

         *

         * @alia OneCoder

         * @author lihzh

         */

        @Override

        public void channelConnected(ChannelHandlerContext ctx,

                                     ChannelStateEvent e) {

            System.out.println(&quot;Hello world, I'm server.&quot;);

        }

    }
}
</span></pre><span style="font-size:18px;"><br><br></span></p><span style="font-size:18px;"><br></span><h1><span style="font-size:18px;">3，客户端</span></h1><p><span style="font-size:18px;">客户端比较简单，启动一个客户端，在获取到服务端链接的方法中打印 hello world</span></p><p><span style="font-size:18px;"><br></span></p><p><pre code_snippet_id="1761093" snippet_file_name="blog_20160713_3_5825797" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.one;

import org.jboss.netty.bootstrap.ClientBootstrap;
import org.jboss.netty.channel.*;
import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

/**
 * Netty 客户端
 * Created by xvshu on 2016/7/13.
 */
public class HelloClient {
    public static void main(String args[]) {

        // Client服务启动器

        ClientBootstrap bootstrap = new ClientBootstrap(

                new NioClientSocketChannelFactory(

                        Executors.newCachedThreadPool(),

                        Executors.newCachedThreadPool()));

        // 设置一个处理服务端消息和各种消息事件的类(Handler)

        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {

            @Override

            public ChannelPipeline getPipeline() throws Exception {

                return Channels.pipeline(new HelloClientHandler());

            }

        });

        // 连接到本地的8000端口的服务端

        bootstrap.connect(new InetSocketAddress(

                &quot;127.0.0.1&quot;, 8000));

    }



    private static class HelloClientHandler extends SimpleChannelHandler {



        /**

         * 当绑定到服务端的时候触发，打印&quot;Hello world, I'm client.&quot;

         *

         * @alia OneCoder

         * @author lihzh

         */

        @Override

        public void channelConnected(ChannelHandlerContext ctx,

                                     ChannelStateEvent e) {

            System.out.println(&quot;Hello world, I'm client.&quot;);

        }

    }
}
</span></pre><span style="font-size:18px;"><br>最后我们先运行服务端，然后运行客户端，发现都打印了hello world ，证明他们两个链接建立成功！</span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">总结：</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 网络是强大的，这些代码在网上就是最简单的示例，却为我们提供了非常好的学习入口，让人感觉简单，这样的感觉，是学习总比不可少的，起码是在初期比不可少的，信息+信心，我们将学习无所不易！</span></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/51901465'>原文链接</a>