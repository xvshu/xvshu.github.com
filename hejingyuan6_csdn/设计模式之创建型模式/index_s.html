<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; 设计模式之创建型模式</div><div style="color:blue" align=center>设计模式之创建型模式</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-family:KaiTi_GB2312; font-size:24px">创建型模式：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp; 抽象工厂模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp; 工厂方法模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp; 建造者模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp; 原型模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp; 单例模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">创建型模式，就是用来创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">对于抽象工厂模式和工厂方法模式查看上篇博文<a href="http://blog.csdn.net/hejingyuan6/article/details/8392815">设计模式之工厂模式</a>，下面就来介绍一下其余3个模式</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:24px">建造者模式</span></h2>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同内部表象的产品对象。如果我们用了建造者模式，那么用户就只需指定需要建造的类型即可，而具体建造的过程和细节就不需要知道了。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">个人理解：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">建造者模式就是将一个复杂对象的构件过程抽象出来（PersonBuilder），不让任何人遗忘当中的任何一步。然后创建一个指挥者类（Director），用它类控制建造过程，也用它来隔离用户与建造过程的关联</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">课本实例：建造小人</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">与工厂方法模式和抽象工厂模式对比：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">举例说明：建造超人</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">工厂方法：通过不同的工厂生产不同的超人，注重的是整体对象的创建方法</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">建造者：注重的是部件构件的过程，旨在通过一步步的精确构造创建出一个复杂的对象。在这个例子中主要是通过具体建造方法建造超人。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">抽象工厂：通过不同的工厂生产一系列超级英雄，注重完整性。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">如图：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="20509669185437.png" alt=""><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">代码如下：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"></span></p>
<pre name="code" class="csharp">//抽象类
  abstract class personbuilder
       {
           protected Graphics g;
           protected Pen p;
   
           public personbuilder(Graphics g, Pen p)
           {
               this.g = g;
               this.p = p;
   
           }
           public abstract void buildhead();
           public abstract void buildbody();
           public abstract void buildarmleft();
           public abstract void buildarmright();
           public abstract void buildlegleft();
           public abstract void buildlegright();
     
      } 
 
 //指挥者
  class personDirector
       {
           private personbuilder pb;
           public personDirector(personbuilder pb)
           {
               this.pb = pb;
   
           }
           public void createperson()
           {
               pb.buildhead();
               pb.buildbody();
               pb.buildarmleft ();
               pb.buildarmright ();
               pb.buildlegleft();
               pb.buildlegright();
   
           }
       }
 </pre><br>
<br>
<p>
<p>
<h2><span style="font-family:KaiTi_GB2312; font-size:24px">原型模式</span></h2>
<p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。原型模式其实就是从一个对象再创建另一个可定制的对象，而且不需要知道任何可创建的细节。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">课本实例：简历复印</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">代码如下：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"></span></p>
<pre name="code" class="csharp">public object Clone()
                 {
                     return (object)this.MemberwiseClone();
                 }
   
 </pre><br>
<br>
<p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">注：MemberwiseClone()方法是这样，如果字段是&#20540;类型，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象，因此，原始对象及其复本引用同一对象</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">总结：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">克隆是创建作为当前实例副本的新对象。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">克隆分为深度克隆和浅度克隆</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">深度克隆:会克隆当前实例的所有所有成员.</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">浅度克隆:只会克隆当前实例的所有&#20540;类型的。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">浅度克隆Object类为我们提供了一个受保护的克隆方法MemberwiseClone()</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">深度克隆要我们自己实现</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">MemberwiseClone方法创建一个浅表副本，具体来说就是创建一个新对象，然后将当前对象的非静态字段复制到该新对象。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">个人理解：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp;&nbsp;</span><span style="font-family:KaiTi_GB2312; font-size:24px">浅拷贝和深拷贝</span></p>
<p style="margin-top:0in; margin-right:0in; margin-bottom:0in; margin-left:1.125in">
<span style="font-family:KaiTi_GB2312; font-size:24px">浅拷贝对于引用的内容来说只是复制了地址，然后给地址赋&#20540;，但深拷贝的引用内容却是根据每个参数不同来实例出一个新的对象</span></p>
<p style="margin-top:0in; margin-right:0in; margin-bottom:0in; margin-left:1.125in">
<span style="font-family:KaiTi_GB2312; font-size:24px">浅拷贝只是拷贝了引用<span lang="en-US">,</span><span lang="zh-CN">指向一个地址空间</span><span lang="en-US">,</span><span lang="zh-CN">而深拷贝是根据参数的不同对这个引用创建新的实例</span></span></p>
<p style="margin-top:0in; margin-right:0in; margin-bottom:0in; margin-left:1.125in; color:red">
<span style="font-family:KaiTi_GB2312; font-size:24px"><span lang="zh-CN"><br>
</span></span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:24px">单例模式</span></h2>
<div><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></div>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">通常我们可以让一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，<span style="color:#ff6666">让类自身负责保存它的唯一实例</span>。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的方法。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">注意问题：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp; 多线程的程序中，多个线程同时，注意是同时访问Singleton类，调用GetInstance（）方法，会有可能造成创建多个实例的。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">线程加锁</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;lock是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">课本实例：只实例化一次工具箱窗体</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">代码如下：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"></span></p>
<pre name="code" class="csharp">private  FormToolbox()
            {
                InitializeComponent();
            }
            public static FormToolbox GetInstance()
            {
                if (ftb == null || ftb.IsDisposed)
                {
                    lock (syncRoot)
                    {
                        if (ftb == null || ftb.IsDisposed)
                        {
                            ftb = new FormToolbox();
                            ftb.MdiParent = Form1.ActiveForm;
    
                        }
                    }
                }
                    return ftb;
                
            }
 </pre><br>
<p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">单例模式：保证一个类仅有一个实例,并提供一个访问它的全局访问点.</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<br>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/8393329'>原文链接</a>