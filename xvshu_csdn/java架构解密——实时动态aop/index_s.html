<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; java架构解密——实时动态aop</div><div style="color:blue" align=center>java架构解密——实时动态aop</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
        <div class="markdown_views"><pre><code>  在上篇博客中个，咱们一起组建了一个容器，里面封装了业务，这样，咱们就将业务和服务的组装放到了客户端，而客户端就相当于咱们的开发中使用到的配置文件，大家发现问题了吗？就是我不能动态改动了？业务容器在代理完成后，重新添加一个容器，这时候，是不被允许的，那这个容器就是个编译时起作用的容器，他就丧失了很多的灵活性！
  那怎么办呢？实际就是调换一下调用顺序就好，大家看看结果：
</code></pre>



<h1 id="1类图对比">1，类图对比</h1>

<p><img src="44160748922325" alt="旧版的系统" title=""></p>

<pre><code>  改造后类图
</code></pre>

<p><img src="30147707934111" alt="改造后的图" title=""></p>

<h1 id="2代码实现">2，代码实现：</h1>



<h2 id="21代理类的变化">2.1代理类的变化：</h2>

<pre class="prettyprint"><code class=" hljs java">
<span class="hljs-javadoc">/**
 * 打招呼动态代理类，给业务类添加功能
 * 前一版本为JDK代理实现
 *  本次添加执行方法之前打印到控制台‘befor’
 *  本次添加执行方法之后打印到控制台‘after’
 *本次版本为DGLIB代理
 *  换代理类原因，JDK代理要求被代理类必须实现某接口，因为它底层实现是新建一个类，实现和被代理类相同的接口
 *  用代理类新建的业务类代替原业务类
 *  CGLIB代理是新建一个类，继承自被代理类，用新建的代理类替换掉原业务类，就不需要接口了
 *
 *5.0版本增加服务组装容器，将服务从代理类中抽离出去了，我们的代理类成为了一个bean
 *6.0将服务容器定义为接口
 *7.0增加业务容器
 *8.0 业务容器不灵活，将获取代理放置到业务容器端，实现动态增加元素，也能拿到代理
 *<span class="hljs-javadoctag"> @author</span> 许恕
 *<span class="hljs-javadoctag"> @version</span> 3.0.0 , 2015年6月16日 下午3:20:13
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CGLibDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> {</span>  

    <span class="hljs-comment">//服务类容器</span>
    <span class="hljs-keyword">private</span> IProxyMehds proxyMehds;

  <span class="hljs-comment">//代理工厂类：单例模式，优化内存开销</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> CGLibDynamicProxy instance = <span class="hljs-keyword">new</span> CGLibDynamicProxy();  

    <span class="hljs-comment">//构造函数</span>
    <span class="hljs-keyword">private</span> <span class="hljs-title">CGLibDynamicProxy</span>() {  
    }  

    <span class="hljs-comment">//获取cglib代理工厂类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CGLibDynamicProxy <span class="hljs-title">getInstance</span>() {  
        <span class="hljs-keyword">return</span> instance;  
    }  

    <span class="hljs-javadoc">/**
     * 使用代理工厂生成某个类的代理
     *
     *<span class="hljs-javadoctag"> @param</span> cls 要代理的类
     *<span class="hljs-javadoctag"> @return</span> 返回已经代理好的类
     */</span>
    <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)  
    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title">getProxy</span>(Class&lt;T&gt; cls) {  
        <span class="hljs-keyword">return</span> (T) Enhancer.create(cls, <span class="hljs-keyword">this</span>);  
    }  


    <span class="hljs-comment">//重写被代理对象的方法执行</span>
    <span class="hljs-comment">//所有的方法执行，到反射的级别都是invoke，重写了这个方法，就重写了所有的方法执行，实现了代理</span>
    <span class="hljs-annotation">@Override</span> 
    <span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span>(Object target, Method method, Object[] args, MethodProxy proxy) <span class="hljs-keyword">throws</span> Throwable {  
        <span class="hljs-comment">//重要改进：从服务容器中执行方法，不再是写死的！</span>
        proxyMehds.beforeBean(); 

        <span class="hljs-comment">//方法正常执行的语句</span>
        Object result = proxy.invokeSuper(target, args);

        <span class="hljs-comment">//重要改进：从服务容器中执行方法，不再是写死的！</span>
        proxyMehds.afterBean(); 


        <span class="hljs-keyword">return</span> result;   
    }

    <span class="hljs-comment">//服务容器的get方法</span>
    <span class="hljs-keyword">public</span> IProxyMehds <span class="hljs-title">getProxyMehds</span>() {
        <span class="hljs-keyword">return</span> proxyMehds;
    }

    <span class="hljs-comment">//服务容器的set方法</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProxyMehds</span>(IProxyMehds proxyMehds) {
        <span class="hljs-keyword">this</span>.proxyMehds = proxyMehds;
    }



}</code></pre>



<h2 id="22业务容器">2.2业务容器</h2>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**
 * 业务类容器：
 *  用map盛放要切入服务的业务类
 *
 *<span class="hljs-javadoctag"> @author</span> 许恕
 *<span class="hljs-javadoctag"> @version</span> 3.0.0 , 2015-6-29 14:25:21
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoMehds</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">IDoMehds</span> {</span>
    <span class="hljs-comment">//盛放执行业务的map</span>
    <span class="hljs-keyword">private</span>  HashMap&lt;String,Object&gt; DoBeans;

    <span class="hljs-comment">//代理类</span>
    <span class="hljs-keyword">private</span> CGLibDynamicProxy proxy ;

    <span class="hljs-javadoc">/**
     * 封装获取元素的方法，每次获取元素都封装一个代理
     *
     *<span class="hljs-javadoctag"> @param</span> 元素的名字
     *<span class="hljs-javadoctag"> @return</span> 代理好的元素
     */</span>
    <span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span>(String beanName){
        <span class="hljs-keyword">return</span> proxy.getProxy(DoBeans.get(beanName).getClass());
    }

    <span class="hljs-comment">//获取业务map</span>
    <span class="hljs-keyword">public</span> HashMap&lt;String, Object&gt; <span class="hljs-title">getDoBeans</span>() {
        <span class="hljs-keyword">return</span> DoBeans;
    }

    <span class="hljs-comment">//设置业务map</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDoBeans</span>(HashMap&lt;String, Object&gt; doBeans) {
        DoBeans = doBeans;
    }

    <span class="hljs-comment">//获取代理类</span>
    <span class="hljs-keyword">public</span> CGLibDynamicProxy <span class="hljs-title">getProxy</span>() {
        <span class="hljs-keyword">return</span> proxy;
    }

    <span class="hljs-comment">//设置代理类</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProxy</span>(CGLibDynamicProxy proxy) {
        <span class="hljs-keyword">this</span>.proxy = proxy;
    }



}</code></pre>



<h2 id="23-客户端">2.3 客户端</h2>

<pre class="prettyprint"><code class=" hljs java"><span class="hljs-javadoc">/**
 * 执行代理程序的客户端
 *
 *<span class="hljs-javadoctag"> @author</span> 许恕
 *<span class="hljs-javadoctag"> @version</span> 3.0.0 , 2015年6月16日 下午3:18:42
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> {</span>

    <span class="hljs-comment">//客户端执行的主方法：系统规定</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) { 
        <span class="hljs-comment">//盛放方法执行前的对象的容器</span>
        HashMap&lt;String,Object&gt; beforBeans;
        HashMap&lt;String,Object&gt; afterBeans;

        <span class="hljs-comment">//配制方法执行前要执行哪些方法</span>
        HashMap&lt;String,String&gt; beforMethods;
        HashMap&lt;String,String&gt; afterMethods;

        <span class="hljs-comment">//实例以上定义的服务类map</span>
        beforMethods=<span class="hljs-keyword">new</span> HashMap();
        beforBeans=<span class="hljs-keyword">new</span> HashMap();
        afterMethods=<span class="hljs-keyword">new</span> HashMap();
        afterBeans=<span class="hljs-keyword">new</span> HashMap();

        <span class="hljs-comment">//将服务类AspectClass1添加到方法执行要加载的服务类</span>
        beforBeans.put(<span class="hljs-string">"AspectClass1"</span>, <span class="hljs-keyword">new</span> AspectClass1());
        beforBeans.put(<span class="hljs-string">"AspectClass2"</span>, <span class="hljs-keyword">new</span> AspectClass2());
        afterBeans.put(<span class="hljs-string">"AspectClass3"</span>, <span class="hljs-keyword">new</span> AspectClass3());
        afterBeans.put(<span class="hljs-string">"AspectClass4"</span>, <span class="hljs-keyword">new</span> AspectClass4());

        <span class="hljs-comment">//规定每个服务类要执行的方法</span>
        beforMethods.put(<span class="hljs-string">"AspectClass1"</span>, <span class="hljs-string">"SayHello"</span>);
        beforMethods.put(<span class="hljs-string">"AspectClass2"</span>, <span class="hljs-string">"SayGoodBye"</span>);
        afterMethods.put(<span class="hljs-string">"AspectClass3"</span>, <span class="hljs-string">"SayHi"</span>);
        afterMethods.put(<span class="hljs-string">"AspectClass4"</span>, <span class="hljs-string">"Eat"</span>);

        <span class="hljs-comment">//实例服务类容器，将四个map传入容器中</span>
        ProxyMehds proxyMehds =<span class="hljs-keyword">new</span> ProxyMehds();
        proxyMehds.setBeforBeans(beforBeans);
        proxyMehds.setBeforMethods(beforMethods);
        proxyMehds.setAfterBeans(afterBeans);
        proxyMehds.setAfterMethods(afterMethods);

        <span class="hljs-comment">//实例业务map</span>
        HashMap&lt;String,Object&gt; DoBeansMap = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt; ();
        <span class="hljs-comment">//将业务装载到map中</span>
        DoBeansMap.put(<span class="hljs-string">"dobeans1"</span>, <span class="hljs-keyword">new</span> GreetingImpl());
        DoBeansMap.put(<span class="hljs-string">"dobeans2"</span>, <span class="hljs-keyword">new</span> EatClass());

        <span class="hljs-comment">//将业务map装载到容器中</span>
        DoMehds doMehds = <span class="hljs-keyword">new</span> DoMehds();
        doMehds.setDoBeans(DoBeansMap);



        <span class="hljs-comment">//实例代理类</span>
        CGLibDynamicProxy cglib =CGLibDynamicProxy.getInstance();

        <span class="hljs-comment">//接受切面</span>
        cglib.setProxyMehds(proxyMehds);
        doMehds.setProxy(cglib);

        <span class="hljs-comment">//接受要代理的对象</span>
        Greeting greeting = (Greeting)doMehds.getBean(<span class="hljs-string">"dobeans1"</span>);
        EatClass eatObject = (EatClass)doMehds.getBean(<span class="hljs-string">"dobeans2"</span>);

        <span class="hljs-comment">//执行对象的某个方法</span>
        greeting.sayHello(<span class="hljs-string">"Jack"</span>);  
        eatObject.Eat();
    } 


}</code></pre>



<h1 id="3总结">3，总结</h1>

<pre><code>    代码的灵活，就像生活一般，在代码灵活的过程中，我们就会对比下生活，生活中，我们每个人，事，物都是独立的对象，而在生活中的时间轴中，我们也是过程化的组织，我们的代码和生活，在思想上都是相同的，优化的不仅仅是代码，还有思想啊！
</code></pre></div>
        <script>
            $(function () {
                $('pre.prettyprint code').each(function () {
                    var lines = $(this).text().split('\n').length;
                    var $numbering = $('<ul/>').addClass('pre-numbering').hide();
                    $(this).addClass('has-numbering').parent().append($numbering);
                    for (i = 1; i <= lines; i++) {
                        $numbering.append($('<li/>').text(i));
                    };
                    $numbering.fadeIn(1700);
                });
            });
        </script>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/46689237'>原文链接</a>