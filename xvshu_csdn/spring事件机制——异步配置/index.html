<div style="color:blue" align=center>spring事件机制——异步配置</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
这里讲解一下Spring对异步事件机制的支持，实现方式有两种：<br>1、全局异步<br>即只要是触发事件都是以异步执行，具体配置（spring-config-register.xml）如下：<br>&nbsp;<pre code_snippet_id="2125894" snippet_file_name="blog_20170113_1_3756377" name="code" class="html">&lt;task:executor id=&quot;executor&quot; pool-size=&quot;10&quot; /&gt;  
&lt;!-- 名字必须是applicationEventMulticaster和messageSource是一样的，默认找这个名字的对象 --&gt;  
&lt;!-- 名字必须是applicationEventMulticaster，因为AbstractApplicationContext默认找个 --&gt;  
&lt;!-- 如果找不到就new一个，但不是异步调用而是同步调用 --&gt;  
&lt;bean id=&quot;applicationEventMulticaster&quot; class=&quot;org.springframework.context.event.SimpleApplicationEventMulticaster&quot;&gt;  
    &lt;!-- 注入任务执行器 这样就实现了异步调用（缺点是全局的，要么全部异步，要么全部同步（删除这个属性即是同步））  --&gt;  
    &lt;property name=&quot;taskExecutor&quot; ref=&quot;executor&quot;/&gt;  
&lt;/bean&gt;  </pre><br><br><br>通过注入taskExecutor来完成异步调用。具体实现可参考之前的代码介绍。这种方式的缺点很明显：要么大家都是异步，要么大家都不是。所以不推荐使用这种方式。<br><p><br></p><p>2、更灵活的异步支持</p>spring3提供了@Aync注解来完成异步调用。此时我们可以使用这个新特性来完成异步调用。不仅支持异步调用，还支持简单的任务调度，比如我的项目就去掉Quartz依赖，直接使用spring3这个新特性，具体可参考spring-config.xml。<br>&nbsp;<br>2.1、开启异步调用支持<br><pre code_snippet_id="2125894" snippet_file_name="blog_20170113_2_6275823" name="code" class="html">&lt;!-- 开启@AspectJ AOP代理 --&gt;  
&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&gt;  
  
&lt;!-- 任务调度器 --&gt;  
&lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot;/&gt;  
  
&lt;!-- 任务执行器 --&gt;  
&lt;task:executor id=&quot;executor&quot; pool-size=&quot;10&quot;/&gt;  
  
&lt;!--开启注解调度支持 @Async @Scheduled--&gt;  
&lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; proxy-target-class=&quot;true&quot;/&gt;  </pre><br>&nbsp;<br><br>2.2、配置监听器让其支持异步调用<br><br><pre code_snippet_id="2125894" snippet_file_name="blog_20170113_3_7781512" name="code" class="html">@Component  
public class EmailRegisterListener implements ApplicationListener&lt;RegisterEvent&gt; {  
    @Async  
    @Override  
    public void onApplicationEvent(final RegisterEvent event) {  
        System.out.println(&quot;注册成功，发送确认邮件给：&quot; + ((User)event.getSource()).getUsername());  
    }  
}  </pre><br><br>使用@Async注解即可，非常简单。&nbsp;<br>这样不仅可以支持通过调用，也支持异步调用，非常的灵活，实际应用推荐大家使用这种方式。<br>通过如上，大体了解了Spring的事件机制，可以使用该机制非常简单的完成如注册流程，而且对于比较耗时的调用，可以直接使用Spring自身的异步支持来优化。   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/54411505'>原文链接</a>