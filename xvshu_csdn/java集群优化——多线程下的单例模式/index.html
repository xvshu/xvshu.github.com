<div style="color:blue" align=center>java集群优化——多线程下的单例模式</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-family:SimSun; font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 在最初学习设计模式时，我为绝佳的设计思想激动不已，在以后的工程中，多次融合设计模式，而在当下的设计中，我们已经觉察出了当初设计模式的高瞻远瞩，但是也有一些不足，需要我们去改进，有人说过，世界上没有绝对的事，当然，再简单的事情，环境变了，也会发生变化，今天和大家一起分享在多线程下单例模式的优化。</span></p>
<h1><span style="font-family:SimSun; font-size:18px">1，传统</span></h1>
<p><span style="font-family:SimSun; font-size:18px">首先，我们回顾下传统的单例（懒汉式）是如何工作的：</span></p>
<p>
<pre name="code" class="java">public class SingletonClass{
    private static SingletonClass instance=null;
    public static SingletonClass getInstance()
    {
        if(instance==null)
        {
               instance=new SingletonClass();
        }
        return instance;
    }
    private SingletonClass(){
    }
}</pre>
<p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px">我们不难看出，在多线程执行时，普通的代码会带了困恼，大家看多线程代码运行时的图片：</span></p>
<p><span style="font-family:SimSun; font-size:18px"><img src="33509418618549" alt=""><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<h1><span style="font-family:SimSun; font-size:18px">2，双重锁</span></h1>
<p><span style="font-family:SimSun; font-size:18px">我们看到线程1和线程2都执行了代码<span style="color:#ff0000; background-color:rgb(255,255,51)">②</span>，我们得到的并不是一个单例的对象，而是多个对象。针对这些我们进行了同步的优化。<br>
</span></p>
<p>
<pre name="code" class="java">public static class Singleton{
    private static Singleton instance=null;
    private Singleton(){
        //do something
    }
    public static Singleton getInstance(){
        if(instance==null){
            synchronized(Singleton.class){
                if(null==instance){
                    instance=new Singleton();
                }
            }
        }
        return instance;
    }
}</pre><span style="font-family:SimSun; font-size:18px"><br>
我们在看看这种代码的多线程运行图：</span>
<p>
<p><span style="font-family:SimSun; font-size:18px"><img src="46293806901225" alt=""><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px">大家看，<span style="color:#ff0000"><span style="background-color:rgb(255,255,51)">③</span></span>只执行了一次，不仅仅是它被同步机制保护了，而且是进行了双重判定，这样保证多线程下单例模式的正常运行。</span></p>
<h1><span style="font-family:SimSun; font-size:18px">3，枚举</span></h1>
<p><span style="font-family:SimSun; font-size:18px">在jdk1.5之后，java注意到这一细节，在创建单例应用时，我们可以利用枚举类型完成我们的工作，并且他是线程安全的。</span></p>
<p><span style="font-family:SimSun; font-size:18px">源码：</span></p>
<p>
<pre name="code" class="java">public enum SingletonEnum
{
&#160; &#160; INSTANCE;
&#160; &#160; private String name;
&#160; &#160; publicString getName()
&#160; &#160; {
&#160; &#160; &#160; &#160;returnname;
&#160; &#160; }
&#160; &#160; &#160;publicvoid setName(String name)
&#160; &#160; {
&#160; &#160; &#160; &#160;this.name = name;
&#160; &#160; }
&#160;}

</pre><span style="font-family:SimSun; font-size:18px"><br>
&nbsp; &nbsp; 这种优化，使我们更优雅地适用代码，但是也带来了一定的问题，就是我们对对象的类型有了模糊的概念，所以在工作中，还是建议保留双锁模式，对一些工具类则可以采取枚举类型优化，简化我们的代码与逻辑。</span>
<p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<h1><span style="font-family:SimSun; font-size:18px">总结：</span></h1>
<p><span style="font-family:SimSun; font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 细节的优化，就像雕琢一件艺术品，我们接触的高人越多，这样的思想就越浓厚，所以，我们常常判断一个人事怎么的品&#26684;与素质，通过他接触的人，朋友就可以推测出来，而计算机内，也是如此，我们接触的优秀框架多了，自己自然就是优秀的设计师！</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span></p>
<p><span style="font-family:SimSun; font-size:18px"><br>
</span><br>
</p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/47106875'>原文链接</a>