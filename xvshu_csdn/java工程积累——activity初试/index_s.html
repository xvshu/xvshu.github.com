<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; java工程积累——activity初试</div><div style="color:blue" align=center>java工程积累——activity初试</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-size:18px">最近在工作中，研究了工作流，这里借助网络上的一些资料，和大家分享下工作流的入门！</span></p>
<h1><span style="font-size:18px">一、什么是Activity？</span></h1>
<span style="font-size:18px">&nbsp; &nbsp; 简单的说：Activity就是布满整个窗口或者悬浮于其他窗口上的交互界面。在一个应用程序中通常由多个Activity构成，都会在Manifest.xml中指定一个主的Activity，如下设置<br>
<br>
<br>
&lt;actionandroid:name=&quot;android.intent.action.MAIN&quot; /&gt;<br>
<br>
<br>
当程序第一次运行时用户就会看这个Activity，这个Activity可以通过启动其他的Activity进行相关操作。当启动其他的Activity时这个当前的这个Activity将会停止，新的Activity将会压入栈中，同时获取用户焦点，这时就可在这个Activity上操作了。都知道栈是先进后出的原则，那么当用户按Back键时，当前的这个Activity销毁，前一个Activity重新恢复。<br>
</span>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">二，简单demo</span></h1>
<span style="font-size:18px">新建工程，编写如下代码：<br>
<br>
<br>
</span><pre code_snippet_id="656795" snippet_file_name="blog_20150430_1_5604666" code_snippet_id="656795" snippet_file_name="blog_20150430_1_5604666" name="code" class="html">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;package com.android.ttx.actiitylifedemo;  
import android.app.Activity;  
import android.os.Bundle;  
import android.util.Log;  
import android.view.KeyEvent;  
public class ActivityLifeDemo extends Activity {  
    private final static String TAG=&quot;ActivityLifeDemo&quot;;  
      
    @Override  
    public void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.main);  
          
        Log.i(TAG, &quot;onCreate&quot;);  
    }  
    @Override  
    protected void onStart() {  
        Log.i(TAG, &quot;onStart&quot;);  
        super.onStart();  
    }  
    @Override  
    protected void onRestart() {  
        Log.i(TAG, &quot;onRestart&quot;);  
        super.onRestart();  
    }  
    @Override  
    protected void onResume() {  
        Log.i(TAG, &quot;onResume&quot;);  
        super.onResume();  
    }  
    @Override  
    protected void onPause() {  
        Log.i(TAG, &quot;onPause&quot;);  
        super.onPause();  
    }  
    @Override  
    protected void onStop() {  
        Log.i(TAG, &quot;onStop&quot;);  
        super.onStop();  
    }  
    @Override  
    protected void onDestroy() {  
        Log.i(TAG, &quot;onDestroy&quot;);  
        super.onDestroy();  
    }  
}  
&lt;/span&gt;  &lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
<br>
<br>
代码很简单，只涉及到一个Activity，一些用户的操作，我们通过记录操作和打印日志的方式来看看Activity的生命周期过程。<br>
<br>
<br>
</span><pre code_snippet_id="656795" snippet_file_name="blog_20150430_2_125880" code_snippet_id="656795" snippet_file_name="blog_20150430_2_125880" name="code" class="html">&lt;span style=&quot;font-size:18px;&quot;&gt;1、  运行
看到如下打印日志：
08-31 08:46:53.916: INFO/ActivityLifeDemo(312): onCreate
08-31 08:46:53.916: INFO/ActivityLifeDemo(312): onStart
08-31 08:46:53.916: INFO/ActivityLifeDemo(312): onResume
2、按下返回按键： 
08-31 09:29:57.396: INFO/ActivityLifeDemo(354): onPause
08-31 09:29:58.216: INFO/ActivityLifeDemo(354): onStop
08-31 09:29:58.216: INFO/ActivityLifeDemo(354): onDestroy
3、长按Home键，弹出最近打开过的应用程序，点击ActivityLifeDemo
08-31 08:51:46.916: INFO/ActivityLifeDemo(312): onCreate
08-31 08:51:46.916: INFO/ActivityLifeDemo(312): onStart
08-31 08:51:46.936: INFO/ActivityLifeDemo(312): onResume
4、按Home键
08-31 08:53:32.676: INFO/ActivityLifeDemo(312): onPause
08-31 08:53:33.796: INFO/ActivityLifeDemo(312): onStop
5、在AllList中点击打开
08-31 08:54:14.286: INFO/ActivityLifeDemo(312): onRestart
08-31 08:54:14.286: INFO/ActivityLifeDemo(312): onStart
08-31 08:54:14.296: INFO/ActivityLifeDemo(312): onResume
&lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
<br>
通过日志信息，我们可以看到。Activity的启动过程：onCreate—onStart—onResume；下返回键时：onPause—onStop—onDestroy 正如上面说是，当按下返回键时，此Activity弹出栈，程序销毁。确实如此，我们再次 打开时的启动过程又回到onCreate—onStart—onResume。OK，启动之后按下Home键，回到Launcher，查看打印信息：onPause—onStop，再次打开的运行过程：onRestart—onStart—onResume。<br>
<br>
<br>
我们通过对Activity的各种操作，构成了Activity的生命周期，我们看到无论对Activity做如何的操作，都会接收到相关的回调方法，那么我们在开发的过程中通过这些回调方法就可以写工作，比如说释放一些重量级的对象，网络连接，数据库连接，文件读等等。<br>
<br>
<br>
<br>
</span>
<h1><span style="font-size:18px">三、启动Activity</span></h1>
<span style="font-size:18px">要启动一个新的Activity，我们可以通过调用Context中的startActivity来启动。像这样：<br>
<br>
<br>
</span><pre code_snippet_id="656795" snippet_file_name="blog_20150430_3_6698000" code_snippet_id="656795" snippet_file_name="blog_20150430_3_6698000" name="code" class="html">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;Intent intent = new Intent(this, ActivityDemo.class);  
startActivity(intent);  // ActivityDemo是需要启动的Activity类  
&lt;/span&gt;  &lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
<br>
<br>
通过上面的方法可以启动新的Activity了，但如果我要从当前的Activity中传递数据到新的Activity呢？很简单：<br>
</span><pre code_snippet_id="656795" snippet_file_name="blog_20150430_4_3477864" code_snippet_id="656795" snippet_file_name="blog_20150430_4_3477864" name="code" class="html">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;Intent intent = new Intent(this,ActivityDemo.class);  
Bundle bundle = new Bundle();  
bundle.putBoolean(&quot;bool_key&quot;, true);  
intent.putExtras(bundle);  
startActivity(intent);  
&lt;/span&gt;  &lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
<br>
<br>
还有，有时候我们需要启动带返回&#20540;的Activity，简单的说就是需要新启动的Activity返回时将&#20540;传递给启动它的Activity，像这样：<br>
<br>
<br>
</span><pre code_snippet_id="656795" snippet_file_name="blog_20150430_5_8413781" code_snippet_id="656795" snippet_file_name="blog_20150430_5_8413781" name="code" class="html">&lt;span style=&quot;font-size:18px;&quot;&gt;&lt;span style=&quot;font-size:18px;&quot;&gt;Intent intent = new Intent(ActivityLifeDemo.this,RevalueActivity.class);  
startActivityForResult(intent, 0x1001);  
&lt;/span&gt;  


ActivityLifeDemo是当前的Activity，启动RevalueActivity，我们在ActivityLifeDemo中需要获取RevalueActivity传回来的值。那么在RevalueActivity中就必须这样写：
&lt;span style=&quot;font-size:18px;&quot;&gt;Intent intent  = new Intent();  
intent.putExtra(&quot;revalue_key&quot;,&quot;haha-revalueActivity&quot;);  
setResult(0x1001, intent);&lt;/span&gt;  
那么“revalue_key”值在哪里获取呢？必须重写onActivityResult方法，通过判断requestCode，来确定
&lt;span style=&quot;font-size:18px;&quot;&gt;if(requestCode==0x1001){  
            String str = data.getStringExtra(&quot;revalue_key&quot;);  
            Log.i(TAG, &quot;返回的值为：&quot;+str);  
        }  
&lt;/span&gt;  &lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
<br>
</span>
<h1><span style="font-size:18px">四、保存状态</span></h1>
<span style="font-size:18px">通过重写onSaveInstanceState（）方法来实现Activity的运行状态，请注意以下几点：<br>
<br>
<br>
1）由于activity 对象被暂停或停止时，它仍然保留在内存里面，关于它的成员信息和当前状态都是活动的，所以此时可以保存Activity的状态，从而使用户所作的Activity的更改保存在内存中<br>
<br>
<br>
2） &nbsp;当系统回收内存而将Activity销毁时，就无法保存其状态，所以需要调用onSaveInstanceState（）方法来实现状态的保存<br>
<br>
<br>
3） &nbsp;很多情况并不需要保持状态信息，比如按下返回键直接关闭程序，所以并不能保证会调用onSaveInstanceState。如果调用了该方法，一般是在onStop 方法之前且可能在 onPause 之后调用。尽管如此，即使你没做任何操作或没有实现 onSaveInstanceState() 方法，你的 activity 状态也能通过Activity 类里面默认实现的 onSaveInstanceState 方法恢复出来。特别是会为布局中的视图（ View ）默认调用onSaveInstanceState 方法，并在这个方法中允许每一个视图提供它需要恢复的任何信息。几乎每一个
 Android框架中的 widget 都视情况实现了这个方法。<br>
<br>
<br>
注：因为 onSaveInstanceState 方法不一定会被调用，所以你应该只是用它来保存一些 activity 的转换过程状态（即 UI 的状态），而不能用来保存永久性数据。但你可以用 onPause 方法在用户离开 activity 时来保存永久性数据，比如需要保存到数据库的数据。<br>
<br>
<br>
有一个很好的方法可以用来检验应用程序保存状态的能力，就是简单地旋转你的设备来改变屏幕的方向。因为当屏幕方向改变时，系统为了给新的方向提供一个可能合适的代替资源，会销毁 activity 并新建一个新的。由于这个原因，你的 activity 是否能在其重新创建时完成保存状态就显得尤为重要，因为用户经常会在使用应用程序时旋转屏幕的。<br>
<br>
<br>
<br>
</span>
<h1><span style="font-size:18px">五、总结</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 大家看到这里对工作流有了个简单的认识，咱们也有了理解，其实任何一种技术，都是对前辈问题的解决，而工作流就是对以前流程问题的总结，说白了，这里的所有的代码都是对以前重复问题的总结！</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 学习任何一种技术，只要从战略上先蔑视他，然后从战术上重视他，他就不是问题！</span></p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/45233941'>原文链接</a>