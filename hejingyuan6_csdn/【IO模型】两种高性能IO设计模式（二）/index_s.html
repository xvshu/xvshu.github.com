<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; 【IO模型】两种高性能IO设计模式（二）</div><div style="color:blue" align=center>【IO模型】两种高性能IO设计模式（二）</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">在传统的网络服务设计模式中，有两种比较经典的模式：</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">一种是 多线程，一种是</span><span lang="en-US"> </span><span lang="zh-CN">线程池。</span></span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件，如下图所示：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;<img src="9186637829576" alt=""></span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">因此，为了解决这种一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询，如下图所示：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><img src="23246506708069" alt="">&nbsp;</span></p><p style="margin:0in"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">从这里可以看出，上篇的五种IO模型中的多路复用IO就是采用Reactor模式。注意，上面的图中展示的是顺序处理每个事件，当然为了提高事件处理速度，可以通过多线程或者线程池的方式来处理事件。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">在Proactor模式中，当检测到有事件发生时，会新起一个异步操作，然后交由内核线程去处理，当内核线程完成IO操作之后，发送一个通知告知操作已完成，可以得知，异步IO模型采用的就是Proactor模式。</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin-top: 7pt; margin-bottom: 7pt; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/47679393'>原文链接</a>