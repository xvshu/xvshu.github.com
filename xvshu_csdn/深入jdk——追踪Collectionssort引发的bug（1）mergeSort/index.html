<div style="color:blue" align=center>深入jdk——追踪Collectionssort引发的bug（1）mergeSort</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p>&nbsp;上篇博客介绍了因为重写比较方法引发的bug，这篇博客，咱们深入以下jdk对Collections.sort的实现，看看这个异常产生的原因，废话不多，先看源码：<br></p><p>1，Collections.sort</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_1_437226" name="code" class="java">public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {
        Object[] a = list.toArray();
        Arrays.sort(a, (Comparator)c);
        ListIterator i = list.listIterator();
        for (int j=0; j&lt;a.length; j++) {
            i.next();
            i.set(a[j]);
        }
    }</pre><br>可以看到只转化为数组，利用数据的排序实现，继续深入：</p><p>2，Arrays.sort</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_2_2421310" name="code" class="java">public static &lt;T&gt; void sort(T[] a, Comparator&lt;? super T&gt; c) {
        if (LegacyMergeSort.userRequested)
            legacyMergeSort(a, c);
        else
            TimSort.sort(a, c);
    }</pre><br>LegacyMergeSort.userRequested的意思就是是否使用jdk6以前的经典算法啊，本篇文章先看经典算法：</p><p><br></p><p>3，legacyMergeSort</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_3_4231454" name="code" class="java">private static &lt;T&gt; void legacyMergeSort(T[] a, Comparator&lt;? super T&gt; c) {
        T[] aux = a.clone();
        if (c==null)
            mergeSort(aux, a, 0, a.length, 0);
        else
            mergeSort(aux, a, 0, a.length, 0, c);
    }</pre><br>关键排序就是mergeSort</p><p><br></p><p>4,mergeSort</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_4_8549852" name="code" class="java">private static void mergeSort(Object[] src,
                                  Object[] dest,
                                  int low,
                                  int high,
                                  int off) {
        int length = high - low;

        // Insertion sort on smallest arrays
        if (length &lt; INSERTIONSORT_THRESHOLD) {
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp;
                         ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        }

        // Recursively sort halves of dest into src
        int destLow  = low;
        int destHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) &gt;&gt;&gt; 1;
        mergeSort(dest, src, low, mid, -off);
        mergeSort(dest, src, mid, high, -off);

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
        if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {
            System.arraycopy(src, low, dest, destLow, length);
            return;
        }

        // Merge sorted halves (now in src) into dest
        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
            if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)
                dest[i] = src[p++];
            else
                dest[i] = src[q++];
        }
    }</pre></p><p>第一部分：</p><p>INSERTIONSORT_THRESHOLD标记采用简单插入算法的数组长度，因为简单插入算法在小范围内的计算效率是优于其他算法。</p><p>简单插入算法：</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_5_5899893" name="code" class="java"> if (length &lt; INSERTIONSORT_THRESHOLD) {
            for (int i=low; i&lt;high; i++)
                for (int j=i; j&gt;low &amp;&amp;
                         ((Comparable) dest[j-1]).compareTo(dest[j])&gt;0; j--)
                    swap(dest, j, j-1);
            return;
        }</pre><br></p><p>第二部分：归并排序：</p><p><pre code_snippet_id="2329453" snippet_file_name="blog_20170413_6_1613732" name="code" class="java">// Recursively sort halves of dest into src
        int destLow  = low;
        int destHigh = high;
        low  += off;
        high += off;
        int mid = (low + high) &gt;&gt;&gt; 1;
        mergeSort(dest, src, low, mid, -off);
        mergeSort(dest, src, mid, high, -off);

        // If list is already sorted, just copy from src to dest.  This is an
        // optimization that results in faster sorts for nearly ordered lists.
        if (((Comparable)src[mid-1]).compareTo(src[mid]) &lt;= 0) {
            System.arraycopy(src, low, dest, destLow, length);
            return;
        }

        // Merge sorted halves (now in src) into dest
        for(int i = destLow, p = low, q = mid; i &lt; destHigh; i++) {
            if (q &gt;= high || p &lt; mid &amp;&amp; ((Comparable)src[p]).compareTo(src[q])&lt;=0)
                dest[i] = src[p++];
            else
                dest[i] = src[q++];
        }</pre><br>大家可以看我的博客，通过舞蹈的形式。了解插入算法的计算过程：<a target="_blank" href="http://blog.csdn.net/xvshu/article/details/70153654" target="_blank">牛！用舞蹈演绎排序</a></p><p>总结：</p><p>这部分是经典的排序算法，在效率上的提升还是在jdk7中的TimSort，留个悬念，咱们下个博客不见不散！！</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/70154094'>原文链接</a>