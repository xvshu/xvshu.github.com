<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; java架构解密——AOP之动态代理实现</div><div style="color:blue" align=center>java架构解密——AOP之动态代理实现</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;在上篇博客中，我们在宏观上介绍了AOP的底层实现，具体见博客<a target="_blank" target="_blank" href="http://blog.csdn.net/xvshu/article/details/44455655">java架构解密——Spring框架的AOP</a>，在博客中，我们讲述了Aop的一些设计上的思路，今天，咱们就具体的实现，和大家一起探讨，看看AOP是怎么一步一步走到今天，而且有些图，也要做些纠正！</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">一，代码演变</span></h1>
<h2><span style="font-size:18px">前提：最初要实现的功能（打招呼）</span></h2>
<p><span style="font-size:18px"><img src="39135427772877" alt=""><br>
</span></p>
<p><span style="font-size:18px">代码：</span></p>
<p><span style="font-size:18px">接口：</span></p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public interface Greeting {
	 void sayHello(String name);  
}&lt;/span&gt;</pre>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<span style="font-size:18px">实现：</span>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class GreetingImpl  implements Greeting {

	@Override 
    public void sayHello(String name) {  
          
        System.out.println(&quot;Hello! &quot; + name);  
         
    }  
 
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
</span>
<p>
<h2><span style="font-size:18px">1，要增加一个功能在打招呼前加入打印“befor”，在打招呼后打印“after”</span></h2>
<p>
<p><span style="font-size:18px"><img src="358230010023914" alt=""></span></p>
<p><span style="font-size:18px">修改后实现：</span></p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class GreetingImpl  implements Greeting {

	@Override 
    public void sayHello(String name) {  
        before();  
        System.out.println(&quot;Hello! &quot; + name);  
        after();  
    }  
 
    private void before() {  
        System.out.println(&quot;Before&quot;);  
    }  
 
    private void after() {  
        System.out.println(&quot;After&quot;);  
    }  
	
}&lt;/span&gt;</pre>
<p>
<h2><span style="font-size:18px">2，我想统一管理这些</span></h2>
<span style="font-size:18px">&nbsp; &nbsp; 如果有一天，图 1 中的深色代码段需要修改，那是不是要打开 3 个地方的代码进行修改？如果不是 3 个地方包含这段代码，而是 100 个地方，甚至是 1000 个地方包含这段代码段，那会是什么后果？<br>
&nbsp; &nbsp; 为了解决这个问题，我们通常会采用将如图 1 所示的深色代码部分定义成一个方法，然后在 3 个代码段中分别调用该方法即可。<br>
<img src="14515318837163" alt=""></span>
<p>
<p><span style="font-size:18px">代理的实现：</span></p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class GreetingProxy implements Greeting {
	private GreetingImpl greetingImpl;  
	 
    public GreetingProxy(GreetingImpl greetingImpl) {  
        this.greetingImpl = greetingImpl;  
    }  
 
    @Override 
    public void sayHello(String name) {  
        before();  
        greetingImpl.sayHello(name);  
        after();  
    }  
 
    private void before() {  
        System.out.println(&quot;Before&quot;);  
    }  
 
    private void after() {  
        System.out.println(&quot;After&quot;);  
    }  
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
注意：这时候，GreetingImpl里没有befor和after方法！</span>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<p>
<h2><span style="font-size:18px">3，动态更换代理</span></h2>
<span style="font-size:18px">&nbsp; &nbsp; 因为软件系统需求变更是很频繁的事情，系统前期设计方法 1、方法 2、方法 3 时只实现了核心业务功能，过了一段时间，我们需要为方法 1、方法 2、方法 3 都增加事务控制；又过了一段时间，客户提出方法 1、方法 2、方法 3 需要进行用户合法性验证，只有合法的用户才能执行这些方法；又过了一段时间，客户又提出方法 1、方法 2、方法 3 应该增加日志记录；又过了一段时间，客户又提出……面对这样的情况，我们怎么办？<br>
</span>
<p>
<p><span style="font-size:18px">类设计：</span></p>
<p><span style="font-size:18px"><img src="31945716532334" alt=""><br>
</span></p>
<p><span style="font-size:18px">JDK代理实现：</span></p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class JDKDynamicProxy 
	implements InvocationHandler {  
		 
	    private Object target;  
	 
	    public JDKDynamicProxy(Object target) {  
	        this.target = target;  
	    }  
	 
	    @SuppressWarnings(&quot;unchecked&quot;)  
	    public &lt;T&gt; T getProxy() {  
	        return (T) Proxy.newProxyInstance(  
	            target.getClass().getClassLoader(),  
	            target.getClass().getInterfaces(),  
	            this 
	        );  
	    }  
	 
	    @Override 
	    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  
	        before();  
	        Object result = method.invoke(target, args);  
	        after();  
	        return result;  
	    }  
	 
	    private void before() {  
	        System.out.println(&quot;Before&quot;);  
	    }  
	 
	    private void after() {  
	        System.out.println(&quot;After&quot;);  
	    }  
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
客户端：</span>
<p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class Client {
	public static void main(String[] args) {  
        Greeting greeting = new JDKDynamicProxy(new GreetingImpl()).getProxy();  
        greeting.sayHello(&quot;Jack&quot;);     
    }  
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
运行时对象的关系：</span>
<p>
<p><span style="font-size:18px"><img src="18922165433268" alt=""><br>
</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<h3><span style="font-size:18px">4.1改进</span></h3>
<p><span style="font-size:18px">缺点：必须有接口<br>
CGLib代理：<br>
<img src="13083285660096" alt=""></span></p>
<p><span style="font-size:18px">CGLIB实现：</span></p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class CGLibDynamicProxy implements MethodInterceptor {  
 
    private static CGLibDynamicProxy instance = new CGLibDynamicProxy();  
 
    
    private CGLibDynamicProxy() {  
    }  
 
    public static CGLibDynamicProxy getInstance() {  
        return instance;  
    }  
 
    @SuppressWarnings(&quot;unchecked&quot;)  
    public &lt;T&gt; T getProxy(Class&lt;T&gt; cls) {  
        return (T) Enhancer.create(cls, this);  
    }  
 
    @Override 
    public Object intercept(Object target, Method method, Object[] args, MethodProxy proxy) throws Throwable {  
        before();  
        Object result = proxy.invokeSuper(target, args);  
        after();  
        return result;  
    }  
 
    private void before() {  
        System.out.println(&quot;Before&quot;);  
    }  
 
    private void after() {  
        System.out.println(&quot;After&quot;);  
    }  
	
	
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
客户端：</span>
<p>
<p>
<pre name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;public class Client {
	public static void main(String[] args) {  
        Greeting greeting = CGLibDynamicProxy.getInstance().getProxy(GreetingImpl.class);  
        greeting.sayHello(&quot;Jack&quot;);  
    } 
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
运行时对象的关系：</span>
<p>
<p><span style="font-size:18px"><img src="39191717550539" alt=""></span></p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">总结：</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 进行到这里，一般的博客也许就会结束了，因为核心内容已经结束了，但是，咱们的征途是星辰和大海，咱们的征途才刚开始，这个AOP还很草率，还没有实现动态的组装，而且咱们的aop切面（公共服务）和代理类写在了一起，等等这些问题，解决这些问题，需要我们站在整个设计思路上下功夫，核心原理懂了，剩下的抽象和封装的工作，是考验一个人另一个能力的时候了，咱们，下节继续！<br>
<br>
</span><br>
</p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/46284875'>原文链接</a>