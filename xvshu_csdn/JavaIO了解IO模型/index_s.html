<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; JavaIO了解IO模型</div><div style="color:blue" align=center>JavaIO了解IO模型</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p style="font-size:14px"><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp; 初听IO，我也是一头雾水，难道除了写入，读出，还有其他的吗？的确在IO的世界中，只有写入读出，但是业务不同，选择的框架不同，IO也会表现不一，而在互联网编程中，IO编程，越来越成为瓶颈，这次，咱们一起来学习下，当下流线个IO概念，</span><span style="font-weight:normal; font-size:14px">下面从同步和异步的概念
 说起，然后是阻塞和非阻塞的区别及阻塞IO和非阻塞IO的区别，然后介绍同步IO和异步IO的区别，接下来介绍了5种IO模型，最后介绍了两种和高性能IO设计相关的设计模式（Reactor和Proactor）。<br>
</span></p>
<h1><span style="font-size:14px; font-weight:normal">一.同步与异步</span></h1>
<span style="font-size:14px; font-weight:normal">　　同步和异步的概念由来已久，网上的说法很多。但是我的理解就很简单：<br>
</span><span style="font-size:14px; font-weight:normal">　　同步：一个门只允许过一个人，不论多少人要过门，请排队<br>
</span><span style="font-size:14px; font-weight:normal">　　异步：我们有N个门，可以同时过N个人，人数小于N时，不用排队<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="23414295732747" alt=""></span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">　　在编程中，同步和异步，就变现为，我的程序是否是可以同时被多个调用者执行，可以将同步和异步与synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。<br>
</span><span style="font-size:14px; font-weight:normal">　　总之，记住，如果一个线程的执行，导致了整个程序的中断，它一定是同步的，否则是异步的！哈哈简单吧！</span>
<p>
<p style="font-size:14px"><span style="font-size:14px; font-weight:normal"><br>
</span></p>
<h1><span style="font-size:14px; font-weight:normal">二.阻塞与非阻塞</span></h1>
<span style="font-size:14px; font-weight:normal">　　阻塞：程序执行到某个阶段，判断是否继续执行，条件不足时，只能等待，直到条件满足<br>
</span><span style="font-size:14px; font-weight:normal">　　非阻塞：程序执行到某个阶段，判断是否继续执行，条件不足时，采取轮询查看条件状态，程序不等待，直到条件满足，继续执行<br>
</span><span style="font-size:14px; font-weight:normal">　 &nbsp; &nbsp;总结：　同步和异步着重点在于多个任务的执行过程中，一个任务的执行是否会导致整个流程的暂时等待；而阻塞和非阻塞着重点在于发出一个请求操作时，如果进行操作的条件不满足是否会持续等待到条件满足。<br>
</span><span style="font-size:14px; font-weight:normal">　　<br>
</span>
<h1><span style="font-size:14px; font-weight:normal">三.阻塞IO与非阻塞IO</span></h1>
<span style="font-size:14px; font-weight:normal">　　通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。<br>
</span><span style="font-size:14px; font-weight:normal">　　当用户线程发起一个IO请求操作（本文以读请求操作为例），内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：<br>
</span><span style="font-size:14px; font-weight:normal">　　1）查看数据是否就绪；<br>
</span><span style="font-size:14px; font-weight:normal">　　2）进行数据拷贝（内核将数据拷贝到用户线程）。<br>
</span><span style="font-size:14px; font-weight:normal">　　那么阻塞（blocking IO）和非阻塞（non-blocking IO）的区别就在于第一个阶段，如果数据没有就绪，在查看数据是否就绪的过程中是一直等待，还是直接返回一个标志信息。<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="15243125430094" alt=""><br>
</span><span style="font-size:14px; font-weight:normal">　　Java中传统的IO都是阻塞IO，比如通过socket来读数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志信息，告知当前线程数据没有就绪，而不是一直在那里等待。</span><span style="font-size:14px; font-weight:normal"><br>
</span>
<h1><span style="font-size:14px; font-weight:normal">四.同步IO与异步IO</span></h1>
<span style="font-size:14px; font-weight:normal">　　同步IO：如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；<br>
</span><span style="font-size:14px; font-weight:normal">　　异步IO： 如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。<br>
</span><span style="font-size:14px; font-weight:normal">　　对于同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，再将数据从内核拷贝到用户线程；<br>
</span><span style="font-size:14px; font-weight:normal">　　而异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。<br>
</span><span style="font-size:14px; font-weight:normal">　　<br>
</span>
<h1><span style="font-size:14px; font-weight:normal">五.五种IO模型</span></h1>
<span style="font-size:14px; font-weight:normal">　　先一睹为快阻塞IO、非阻塞IO、多路复用IO、信号驱动IO以及异步IO。<br>
</span><span style="font-size:14px; font-weight:normal">　　<br>
</span><span style="font-size:14px; font-weight:normal">1.阻塞IO模型<br>
</span><span style="font-size:14px; font-weight:normal">　　最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。<br>
</span><span style="font-size:14px; font-weight:normal">　　当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。<br>
</span><span style="font-size:14px; font-weight:normal">　　典型的阻塞IO模型的例子为：<br>
</span><span style="font-size:14px; font-weight:normal">data = socket.read();<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp;　　如果数据没有就绪，就会一直阻塞在read方法。</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">2.非阻塞IO模型<br>
</span><span style="font-size:14px; font-weight:normal">　　当用户线程发起一个read操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。<br>
</span><span style="font-size:14px; font-weight:normal">　　所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。<br>
</span><span style="font-size:14px; font-weight:normal">　　典型的非阻塞IO模型一般如下：</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">while(true){<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; data = socket.read();<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; if(data!= error){<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp; 处理数据<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp; break;<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; }<br>
</span><span style="font-size:14px; font-weight:normal">}<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp;　　但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">3.多路复用IO模型<br>
</span><span style="font-size:14px; font-weight:normal">　　多路复用IO模型是目前使用得比较多的模型。Java NIO实际上就是多路复用IO。<br>
</span><span style="font-size:14px; font-weight:normal">　　在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写事件时，才真正调用实际的IO读写操作。因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。<br>
</span><span style="font-size:14px; font-weight:normal">　　在Java NIO中，是通过selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。<br>
</span><span style="font-size:14px; font-weight:normal">　　也许有朋友会说，我可以采用 多线程&#43; 阻塞IO 达到类&#20284;的效果，但是由于在多线程 &#43; 阻塞IO 中，每个socket对应一个线程，这样会造成很大的资源占用，并且尤其是对于长连接来说，线程的资源一直不会释放，如果后面陆续有很多连接的话，就会造成性能上的瓶颈。<br>
</span><span style="font-size:14px; font-weight:normal">　　而多路复用IO模式，通过一个线程就可以管理多个socket，只有当socket真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用IO比较适合连接数比较多的情况。<br>
</span><span style="font-size:14px; font-weight:normal">　　另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。<br>
</span><span style="font-size:14px; font-weight:normal">　　不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">4.信号驱动IO模型<br>
</span><span style="font-size:14px; font-weight:normal">　　在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">5.异步IO模型<br>
</span><span style="font-size:14px; font-weight:normal">　　异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。<br>
</span><span style="font-size:14px; font-weight:normal">　　也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用iO函数进行实际的读写操作。<br>
</span><span style="font-size:14px; font-weight:normal">　　注意，异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO。<br>
</span><span style="font-size:14px; font-weight:normal">　　前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。</span>
<p>
<p style="font-size:14px"><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">六.两种高性能IO设计模式</span><span style="font-size:14px; font-weight:normal"><br>
</span><span style="font-size:14px; font-weight:normal">　　在传统的网络服务设计模式中，有两种比较经典的模式：<br>
</span><span style="font-size:14px; font-weight:normal">　　多线程<br>
</span><span style="font-size:14px; font-weight:normal">　　对于多线程模式，也就说来了client，服务器就会新建一个线程来处理该client的读写事件。<br>
</span><span style="font-size:14px; font-weight:normal">　　这种模式虽然处理起来简单方便，但是由于服务器为每个client的连接都采用一个线程去处理，使得资源占用非常大。因此，当连接数量达到上限时，再有用户请求连接，直接会导致资源瓶颈，严重的可能会直接导致服务器崩溃。<br>
</span><span style="font-size:14px; font-weight:normal">&nbsp; &nbsp; &nbsp; &nbsp; 线程池<br>
</span><span style="font-weight:normal"><span style="font-size:13.6842107772827px">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span><span style="font-size:14px">为了解决一个线程对应一个客户端模式带来的问题，提出了采用线程池的方式，也就说创建一个固定大小的线程池，来一个客户端，就从线程池取一个空闲线程来处理，当客户端处理完读写操作之后，就交出对线程的占用。因此这样就避免为每一个客户端都要创建线程带来的资源浪费，使得线程可以重用。<br>
</span></span><span style="font-size:14px">　　但是线程池也有它的弊端，如果连接大多是长连接，因此可能会导致在一段时间内，线程池中的线程都被占用，那么当再有用户请求连接时，由于没有可用的空闲线程来处理，就会导致客户端连接失败，从而影响用户体验。因此，线程池比较适合大量的短连接应用。<br>
</span><span style="font-weight:normal"><span style="font-size:14px">　　因此便出现了下面的两种高性能IO设计模式：Reactor和Proactor。<br>
</span></span><span style="font-weight:normal"><span style="font-size:14px">　　在Reactor模式中，会先对每个client注册感兴趣的事件，然后有一个线程专门去轮询每个client是否有事件发生，当有事件发生时，便顺序处理每个事件，当所有事件处理完之后，便再转去继续轮询。</span></span><span style="font-weight:normal"><span style="font-size:14px"><br>
</span></span></p>
<h1><span style="font-weight:normal"><span style="font-size:14px">总结：</span></span></h1>
<span style="font-size:13.6842107772827px">&nbsp; &nbsp; &nbsp; &nbsp;看过这么多的IO我们可以得出一个结论，就是对IO的优化，更多的是对锁的管理，而这样的管理更多是多线程方面的管理，我们对于多线程方面的经验就可以平移到IO这里来，这恰恰就是我们提倡的学习方法，由厚到薄的过程！计算机其实就是一台运行加减法的机器，所有的技术，到了底层全是0和1的操作，所以，计算机天生就是简单的代名词！</span>
<p>
<h1 class="postTitle"><span style="font-weight:normal"></span></h1>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/47621067'>原文链接</a>