<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; WF40——升级技能：泛型应用</div><div style="color:blue" align=center>WF40——升级技能：泛型应用</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<h1><span style="font-size:18px">前提：</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 在项目的开发中，我们知道，加入泛型，通过对类型的封装，进行抽象后，可以大大减少我们代码量，在项目中，泛型可以说是高级工程师必备的技能之一，也是面向对象的核心“抽象”的技术基础之一，他这么牛，在工作流的开发中，我们不免就要考虑！</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 还有一个技术，也是一个重要的内容，就是委托，在项目中，我们通过委托可以对层级之间，对象之间的关系就行解耦，将耦合延迟到运行状态时进行绑定，这样我们就能在改动较为少的前提下对项目的变动作出快速的反应！而在工作流的开发过程中，我们也是要加入的必备技术！（请关注我的下片博客）</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">原因：</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 下面给大家介绍我们为什么加入这两种技术的原因：</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 在普通的工作流开发中，我们在上篇博客中已经介绍过，他造成了一个严重的影响，就是结点太多了！我们看一幅图（实际项目中的例子，很有说服力）</span></p>
<p><span style="font-size:18px"><img src="36148339501498" alt=""><br>
</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 大家认真观察不难发现，我们将近有几十个结点，而这些点的开发将是我们噩梦的开始，我们每个人基本上都会发现，这个结点和其他几个结点只有几个不同的地方，90%都是相&#20284;的，而我们却傻傻地写了所有的代码，聪明一点的，还会复制粘贴，但是我们是面向对象的工程师，我们应该有更好的解决方案。</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 而这时，我们自觉想到了泛型，他就是对类型的抽象，有了它，我们就可以只关心我们特定的逻辑，而根据客户端类型的确定，我们就可以复用公共的逻辑！</span></p>
<h1><span style="font-size:18px">代码对比：</span></h1>
<h2><span style="font-size:18px">&nbsp; &nbsp; &nbsp; 一般代码：</span></h2>
<p>
<pre name="code" class="csharp">&lt;span style=&quot;font-size:18px;&quot;&gt;public sealed class Activity_ToDo : CodeActivity
    {
        // 定义一个字符串类型的活动输入参数
        public InArgument&lt;Login.Model.Entity.Case&gt; CaseIn { get; set; }
        public OutArgument&lt;Login.Model.Entity.Case&gt; CaseOut { get; set; }

        // 如果活动返回值，则从 CodeActivity&lt;TResult&gt;
        // 派生并从 Execute 方法返回该值。
        protected override void Execute(CodeActivityContext context)
        {
            Login.Model.Entity.Case info = new Login.Model.Entity.Case();

            BaseEntityAbstract cache = new BaseEntityHelper();
            cache.GetTableInfo(typeof(Login.Model.Entity.Case));
            CommonData.Data.Core.SQLCore.SqlHelper sq = new CommonData.Data.Core.SQLCore.SqlHelper();

            info.Id = CaseIn.Get(context).Id;
            info.CaseName = CaseIn.Get(context).CaseName;
            info.State = &quot;正在办理&quot;;
            info.InstanceID = CaseIn.Get(context).InstanceID;
            info.UserId = CaseIn.Get(context).UserId;

            sq.Update&lt;Login.Model.Entity.Case&gt;(info);
            info = sq.GetEntity&lt;Login.Model.Entity.Case&gt;(&quot;InstanceID&quot;, info.InstanceID);

            //CaseOut.Set(context, info);
            context.SetValue(CaseOut, info);
            //Login.Model.Entity.Case caseThisCon = context.GetValue(this.CaseOut); 
        }
    }&lt;/span&gt;</pre><span style="font-size:18px"><br>
</span>
<p>
<h2><span style="font-size:18px">使用泛型之后的代码：</span></h2>
<p>
<p>
<pre name="code" class="csharp">&lt;span style=&quot;font-size:18px;&quot;&gt;public sealed class CodeActivityevent&lt;T&gt; : CodeActivity
    {

       
        /// &lt;summary&gt;
        /// 传入参数，案件实体
        /// &lt;/summary&gt;
        public InArgument&lt;T&gt; CaseIn { get; set; }
        
        /// &lt;summary&gt;
        /// 传出参数，案件实体
        /// &lt;/summary&gt;
        public OutArgument&lt;T&gt; CaseOut { get; set; }

        /// &lt;summary&gt;
        /// 执行创建案件
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;context&quot;&gt;&lt;/param&gt;
        protected override void Execute(CodeActivityContext context)
        {
			//获取实体操作类
			BaseEntityAbstract cache = new BaseEntityHelper();
            cache.GetTableInfo(typeof(Login.Model.Entity.Case));
            CommonData.Data.Core.SQLCore.SqlHelper sq = new CommonData.Data.Core.SQLCore.SqlHelper();
			
            //获取传入参数的两种方法
            T CaseUse = CaseIn.Get&lt;T&gt;(context);
            //调用业务逻辑层，将获取的实体传入，接收返回的实体，并将其付给传出参数

            //TODO:基础活动：修改实体的逻辑层
            //返回的案件实体CaseBack
            T CaseBack = sq.Save(CaseUse);

            //将返回的实体传出
            //CaseOut.Set(context, info);
            context.SetValue(CaseOut, CaseBack);

        }
    }&lt;/span&gt;</pre>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p>
<h2><span style="font-size:18px">代码对比结果</span></h2>
<p>
<p><span style="font-size:18px">&nbsp; &nbsp; 我们发现使用泛型后有几点好处：</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 1，代码复用，这样我们多有的保存操作都可以用一个代码活动解决</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 2，公共服务，我们规定好基本的代码结构后，想要给所有的公共服务增加一个功能，则只需改动一个类就可以</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; 我们又发现了几点工作流的好处：</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 1，解耦逻辑，在逻辑处理这一层大部分有工作流性质的业务可以使用工作流泽合逻辑处理层，而工作流就是xml文件，所以他的改动是一个解耦行为</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 2，扩充简单，我们在某一个小型复用工作流中，对其功能的扩充就是开发扩充模块，加入工作流就ok了</span></p>
<h1><span style="font-size:18px">总结：</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 我们使用任何技术，只要这个技术存在的时间够长，我们有理由相信，我们遇到的问题，前人肯定遇到过，他们肯定通过N种方法解决了这种困难，我们要做的就是找到他，研究它，在这个技术基础上先进行公共服务抽象，然后就是具体业务的编写，我们这个过程中，我们的收货，不仅仅是技术的获得，还有抽象理念的提升及面向对象的加深！像老师说，我们要在架构层面上进行开发！</span></p>
<div><span style="font-size:18px"><br>
</span></div>
<span style="font-size:18px"><br>
</span>
<p><span style="font-size:18px"><br>
</span></p>
<p><br>
</p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/38962147'>原文链接</a>