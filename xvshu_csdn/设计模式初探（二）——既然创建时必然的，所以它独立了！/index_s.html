<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; 设计模式初探（二）——既然创建时必然的，所以它独立了！</div><div style="color:blue" align=center>设计模式初探（二）——既然创建时必然的，所以它独立了！</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 面向对象设计，一个必不可少的步骤是“实例化”，如果将实例化与具体的实现紧密地结合在一起……简单的创建，当然这是没有问题的，但是，如果我们不是简单的创建呢，我们需要改变具体的算法，需要扩展算法的种类，需要系统在改变之后还是以前的样子运行！那么，问题就会变得复杂，多变！</span></p>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在创建型的几个设计模式中，将具体算法的实现与实例化分离，工厂方法是这方面的典范，其他的创建型设计模式起到扩展和辅助的作用！</span></p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px"><img alt="" src="39632087001894.png"></span></p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在书中举得那些例子，都很有趣，大家可以好好看看，在这里咱们说说一些扩展的知识。</span></p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 反射：我个人肤浅的理解是，应用程序在运行时，可以动态地获得一个类型的属性，方法，事件等信息，这样就可以在工厂中动态地创建一个对象了！</span></p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; c#代码：</span></p>
<pre class="csharp" name="code">Assembly.Load(&quot;程序集&quot;) //Assembly.LoadFile(&quot;外部调用的动态库&quot;)加载程序集,返回类型是一个Assembly
</pre>
<p>&nbsp;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="font-size:18px">&nbsp; 实际应用：</span></p>
<p><span style="font-size:18px"></span>&nbsp;</p>
<p>&nbsp;</p>
<pre class="csharp" name="code">//引入反射
using System.Reflection;

//引入config配置文件
using System.Configuration ;


  //反射优化抽象工厂

    //根据配置文件选择创建查询方式
    class DateAccess
    {
        private static readonly string AssemblyName = &quot;shujuku&quot;;

        //利用配置文件:1,添加引用system.configuration ; 2, using system.configuration 
        //读取配置文件app.config里的DB
        private static readonly string db = ConfigurationManager.AppSettings[&quot;DB&quot;];
        //private static readonly string db = &quot;Sqlserver&quot;;

        //静态函数创建用户表
        public static IUser CreateUser()
        {
            string classname = AssemblyName + &quot;.&quot; + db + &quot;User&quot;;
				//利用反射创建对象
            return (IUser)Assembly.Load(AssemblyName).CreateInstance(classname);
        }

        //静态函数创建表
        public static IDepartment  CreateDepartment()
        {
            string classname = AssemblyName + &quot;.&quot; + db + &quot;Department&quot;;
				//利用反射创建对象
            return (IDepartment )Assembly.Load(AssemblyName).CreateInstance(classname);
        }
    }
</pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><span style="font-size:18px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在程序设计中，创建型模式已经给我们带来了意想不到的好处，让我们的工作更轻松，简单，但是不要忘了一种模式只是解决一种特定的问题，下次我们将介绍更多的模式，解决更多的问题！</span></p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/8432078'>原文链接</a>