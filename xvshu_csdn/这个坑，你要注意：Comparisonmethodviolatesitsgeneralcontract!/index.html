<div style="color:blue" align=center>这个坑，你要注意：Comparisonmethodviolatesitsgeneralcontract!</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<h1>背景</h1><p>有部分业务需要进行排序，对比的对象是某实体里的金额（double 类型），这样，我们实现了自定义的比较类，结果运行一段时间之后报了错误：Comparison method violates its general contract! ，经过校验，发现错误出现在自定义排序上，经网上各种查阅资料发现是jdk7的兼容问题，以下将解决过程分享给大家。<br></p><h1>错误截图：</h1><p><br></p><p><img src="6925077595116" height="156" width="846" alt=""><br></p><div class="dp-highlighter bg_java"><br>重写的比较方法：<br><img src="32486589935606" alt=""><br></div><h1>解决方案</h1><p>先说如何解决，解决方式有两种。</p><h2>修改代码</h2><p>上面代码写的本身就有问题，第4行没有考虑o1 == o2的情况，再者说我们不需要自己去比较，修改为如下代码即可：</p><p><pre code_snippet_id="2329367" snippet_file_name="blog_20170413_1_327148" name="code" class="java">/**
	 * 对比类：根据持有金额
	 */
	private static class  TenderCollectComparator implements Comparator&lt;TenderCollect&gt; {

		public int compare(TenderCollect b1, TenderCollect b2) {

			return b1.getTocollectmoney().compareTo(b2.getTocollectmoney());
		}
	}</pre><br><br></p><p><br></p><p>不修改代码</p><p>那么问题来了。为什么上面代码在JDK6中运行无问题，而在JDK7中却会抛异常呢？这是因为JDK7底层的排序<a target="_blank" href="http://lib.csdn.net/base/datastructure" class="replace_word" title="算法与数据结构知识库" target="_blank" style="color:#df3434; font-weight:bold;">算法</a>换了，如果要继续使用JDK6的排序算法，可以在JVM的启动参数中加入如下参数：</p><div class="dp-highlighter bg_plain"><div class="bar"><div class="tools"><strong>[plain]</strong> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="ViewSource" title="view plain">view plain</a><span data-mod="popu_168"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="CopyToClipboard" title="copy">copy</a></span><span data-mod="popu_169"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="PrintSource" title="print">print</a></span><a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="About" title="?">?</a><span class="tracking-ad" data-mod="popu_167"><a target="_blank" href="https://code.csdn.net/snippets/556305" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;" height="12" width="12"></a></span><span class="tracking-ad" data-mod="popu_170"><a target="_blank" href="https://code.csdn.net/snippets/556305/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;" height="12" width="12"></a></span></div></div><ol start="1"><li class="alt"><span><span>-Djava.util.Arrays.useLegacyMergeSort=true&nbsp;&nbsp;</span></span></li></ol></div>这样就会照旧使用JDK6的排序算法，在不能修改代码的情况下，解决这个兼容的问题。<h1>分析</h1><p>在我以前的认知中，高版本的JDK是可以兼容之前的代码的，与同事讨论了一番另加搜索了一番，事实证明，JDK6到JDK7确实存在兼容问题（<a target="_blank" target="_blank" href="http://www.oracle.com/technetwork/java/javase/compatibility-417013.html#incompatibilities">不兼容列表</a>）。在不兼容列表中我们可以找到关于Collections.sort的不兼容说明，如下：</p><div class="dp-highlighter bg_plain"><div class="bar"><div class="tools"><strong>[plain]</strong> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="ViewSource" title="view plain">view plain</a><span data-mod="popu_168"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="CopyToClipboard" title="copy">copy</a></span><span data-mod="popu_169"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="PrintSource" title="print">print</a></span><a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="About" title="?">?</a><span class="tracking-ad" data-mod="popu_167"><a target="_blank" href="https://code.csdn.net/snippets/556305" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;" height="12" width="12"></a></span><span class="tracking-ad" data-mod="popu_170"><a target="_blank" href="https://code.csdn.net/snippets/556305/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;" height="12" width="12"></a></span></div></div><ol start="1"><li class="alt"><span><span>Area:&nbsp;API:&nbsp;Utilities&nbsp;&nbsp;</span></span></li><li><span>Synopsis:&nbsp;Updated&nbsp;sort&nbsp;behavior&nbsp;for&nbsp;Arrays&nbsp;and&nbsp;Collections&nbsp;may&nbsp;throw&nbsp;an&nbsp;IllegalArgumentException&nbsp;&nbsp;</span></li><li class="alt"><span>Description:&nbsp;The&nbsp;sorting&nbsp;algorithm&nbsp;used&nbsp;by&nbsp;java.util.Arrays.sort&nbsp;and&nbsp;(indirectly)&nbsp;by&nbsp;java.util.Collections.sort&nbsp;has&nbsp;been&nbsp;replaced.&nbsp;&nbsp;&nbsp;</span></li><li><span>The&nbsp;new&nbsp;sort&nbsp;implementation&nbsp;may&nbsp;throw&nbsp;an&nbsp;IllegalArgumentException&nbsp;if&nbsp;it&nbsp;detects&nbsp;a&nbsp;Comparable&nbsp;that&nbsp;violates&nbsp;the&nbsp;Comparable&nbsp;contract.&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>The&nbsp;previous&nbsp;implementation&nbsp;silently&nbsp;ignored&nbsp;such&nbsp;a&nbsp;situation.&nbsp;&nbsp;</span></li><li><span>If&nbsp;the&nbsp;previous&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;you&nbsp;can&nbsp;use&nbsp;the&nbsp;new&nbsp;system&nbsp;property,&nbsp;java.util.Arrays.useLegacyMergeSort,&nbsp;&nbsp;&nbsp;</span></li><li class="alt"><span>to&nbsp;restore&nbsp;previous&nbsp;mergesort&nbsp;behavior.&nbsp;&nbsp;</span></li><li><span>Nature&nbsp;of&nbsp;Incompatibility:&nbsp;behavioral&nbsp;&nbsp;</span></li><li class="alt"><span>RFE:&nbsp;6804124&nbsp;&nbsp;</span></li></ol></div>描述的意思是说，java.util.Arrays.sort(java.util.Collections.sort调用的也是此方法)方法中的排序算法在JDK7中已经被替换了。如果违法了比较的约束新的排序算法也许会抛出llegalArgumentException异常。JDK6中的实现则忽略了这种情况。那么比较的约束是什么呢？<a target="_blank" target="_blank" href="http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html#compare%28T,%20T%29">看这里</a>，大体如下：<br><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><p><img src="20906915944702" alt=""></p></blockquote><ul><li>sgn(compare(x, y)) == -sgn(compare(y, x))<br></li><li>((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0)) implies compare(x, z)&gt;0<br></li><li>compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z</li></ul><div>再回过头来看我们开篇有问题的实现：<div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><strong>[java]</strong> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="ViewSource" title="view plain">view plain</a><span data-mod="popu_168"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="CopyToClipboard" title="copy">copy</a></span><span data-mod="popu_169"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="PrintSource" title="print">print</a></span><a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="About" title="?">?</a><span class="tracking-ad" data-mod="popu_167"><a target="_blank" href="https://code.csdn.net/snippets/556305" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;" height="12" width="12"></a></span><span class="tracking-ad" data-mod="popu_170"><a target="_blank" href="https://code.csdn.net/snippets/556305/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;" height="12" width="12"></a></span></div></div><ol start="1" class="dp-j"><li class="alt"><span><span class="keyword">return</span><span>&nbsp;x&nbsp;&gt;&nbsp;y&nbsp;?&nbsp;</span><span class="number">1</span><span>&nbsp;:&nbsp;-</span><span class="number">1</span><span>;&nbsp;&nbsp;</span></span></li></ol></div>当x == y时，sgn(compare(x, y)) &nbsp;= -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束，所以在JDK7中抛出了本文标题的异常。</div><h1>结论</h1><div>那么现在是否可以盖棺定论了，按照上面的分析来看，使用这种比较方式（return x &gt; y ? 1 : -1;），只要集合或数组中有相同的元素，就会抛出本文标题的异常。实则不然，什么情况下抛出异常，还取决于JDK7底层排序算法的实现，也就是大名鼎鼎的<a target="_blank" target="_blank" href="http://svn.python.org/projects/python/trunk/Objects/listsort.txt">TimSort</a>。后面文章会分析TimSort。本文给出一个会引发该异常的Case，以便有心人共同研究，如下：<div class="dp-highlighter bg_java"><div class="bar"><div class="tools"><strong>[java]</strong> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="ViewSource" title="view plain">view plain</a><span data-mod="popu_168"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="CopyToClipboard" title="copy">copy</a></span><span data-mod="popu_169"> <a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="PrintSource" title="print">print</a></span><a target="_blank" href="http://blog.csdn.net/ghsau/article/details/42012365#" class="About" title="?">?</a><span class="tracking-ad" data-mod="popu_167"><a target="_blank" href="https://code.csdn.net/snippets/556305" target="_blank" title="在CODE上查看代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/CODE_ico.png" alt="在CODE上查看代码片" style="position:relative;top:1px;left:2px;" height="12" width="12"></a></span><span class="tracking-ad" data-mod="popu_170"><a target="_blank" href="https://code.csdn.net/snippets/556305/fork" target="_blank" title="派生到我的代码片" style="text-indent:0;"><img src="https://code.csdn.net/assets/ico_fork.svg" alt="派生到我的代码片" style="position:relative;top:2px;left:2px;" height="12" width="12"></a></span></div></div><ol start="1" class="dp-j"><li class="alt"><span><span>Integer[]&nbsp;array&nbsp;=&nbsp;&nbsp;&nbsp;</span></span></li><li><span>{<span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">3</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;</span><span class="number">0</span><span>,&nbsp;&nbsp;&nbsp;</span></span></li></ol></div></div>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/70153759'>原文链接</a>