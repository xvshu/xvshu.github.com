<div style="color:blue" align=center>JAVA重定向与转发</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<h1><strong><span style="font-family:KaiTi_GB2312;font-size:18px;">一、调用方式</span></strong></h1><p><strong><span style="FONT-FAMILY: 宋体; FONT-SIZE: 14pt"><br></span></strong></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">我们知道，在servlet中调用转发、重定向的语句如下：</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">request.getRequestDispatcher(&quot;new.jsp&quot;).forward(request, response);&nbsp;&nbsp; //转发到new.jsp</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">response.sendRedirect(&quot;new.jsp&quot;);&nbsp;&nbsp; //重定向到new.jsp</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">在jsp页面中你也会看到通过下面的方式实现转发：</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">&lt;jsp:forward page=&quot;apage.jsp&quot; /&gt;</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">当然也可以在jsp页面中实现重定向：</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">&lt;%response.sendRedirect(&quot;new.jsp&quot;); %&gt;&nbsp;//重定向到new.jsp</span></p><p><br></p><h1><span style="font-family:KaiTi_GB2312;font-size:18px;"><strong>二，对比</strong></span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">当使用转发时，JSP容器将使用一个内部的方法来调用目标页面，新的页面继续处理同一个请求，而浏览器将不会知道这个过程。</span><span style="font-family: KaiTi_GB2312;font-size:18px;">与之相反，重定向方式的含义是第一个页面通知浏览器发送一个新的页面请求。因为，当你使用重定向时，浏览器中所显示的URL会变成新页面的URL, 而当使用转发时，该URL会保持不变。重定向的速度比转发慢，因为浏览器还得发出一个新的请求。同时，由于重定向方式产生了一个新的请求，所以经过一次重 定向后，request内的对象将无法使用。&nbsp;</span></p><p><span style="font-family: KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">怎么选择是重定向还是转发呢？通常情况下转发更快，而且能保持request内的对象，所以他是第一选择。但是由于在转发之后，浏览器中URL仍然指向开始页面，此时如果重载当前页面，开始页面将会被重新调用。如果你不想看到这样的情况，则选择转发。</span><br></p><p><br></p><p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">故：不要仅仅为了把变量传到下一个页面而使用session作用域，那会无故增大变量的作用域，转发也许可以帮助你解决这个问题。 <br>重定向：以前的request中存放的变量全部失效，并进入一个新的request作用域。 <br>转发：以前的request中存放的变量不会失效，就像把两个页面拼到了一起。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><h1><span style="font-family:KaiTi_GB2312;font-size:18px;"><strong>三，实例介绍</strong></span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">提到转发和重定向就不得不提到request作用域。很多初学者都知道当我们提交一个表单时，就创建了一个新的请求。实际上，当我们点击一个链接时，也创建 了一个新的请求。那么一个请求的作用于到底有多大呢？例如：在页面a.jsp中有一个链接&lt;a href=&quot;b.jsp?id=1&quot;&gt;这是指向b的一个链接，而且还带了一个参数&lt;/a&gt;。当我们点击这个连接的时候，就产生了一个请 求，为了明确起见，我们把它叫做requestA-&gt;B。现在，在b.jsp页面中我们就可以从这个请求中获取信息了。在b.jsp中你可以写入 out.println(request.getParameter(&quot;id&quot;))进行测试。下面更复杂一点，我们在b.jsp页面中增加下面的语句：<br><br>request.setAttribute(&quot;name&quot;,&quot;funcreal&quot;);<br><br>out.println(request.getAttriblute(&quot;name&quot;));//成功显示了name变量的值。<br><br>现 在在b.jsp中再增加一个链接：&lt;a href=&quot;c.jsp?age=23&quot;&gt;这是指向c的一个链接，而且还带了一个参数&lt;/a&gt;,当我们点击这个连接的时候，将产生一个 新的请求，这时requestA-B也就安息了，新的请求叫做requestB-C。同样的道理，在c.jsp中，我们可以访问到的变量只有age，因为 id，name这两个变量都属于requestA-B，此时他已经不存在了。</span></p><p><br></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">下面是源代码：</span><br><br></p><p><pre name="code" class="html">a.jsp
&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;
&lt;html&gt;
&lt;body bgcolor=&quot;#ffffff&quot;&gt;
&lt;a href=&quot;b.jsp?id=1&quot;&gt;指向b.jsp，而且还带了一个参数id=1。requestA-B现在诞生了&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

b.jsp
&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;
&lt;html&gt;
&lt;body bgcolor=&quot;#ffffff&quot;&gt;
&lt;%
out.println(&quot;id=&quot; + request.getParameter(&quot;id&quot;));
request.setAttribute(&quot;name&quot;,&quot;Func Real&quot;);
out.println(&quot;name=&quot; + request.getAttribute(&quot;name&quot;));
%&gt;
&lt;a href=&quot;c.jsp?age=23&quot;&gt;requestA-B已经结束了。指向c.jsp，而且还带了一个参数age=23&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;

c.jsp
&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;
&lt;html&gt;
&lt;body bgcolor=&quot;#ffffff&quot;&gt;
&lt;%
out.println(&quot;id=&quot; + request.getParameter(&quot;id&quot;));
out.println(&quot;name=&quot; + request.getAttribute(&quot;name&quot;));
out.println(&quot;age=&quot; + request.getParameter(&quot;age&quot;));
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre><br><span style="font-family:KaiTi_GB2312;font-size:18px;">那么转发又是怎么回事呢？现在增加一个页面叫做d.jsp，并且在c.jsp中&lt;/body&gt;前面增加一句&lt;jsp:forward page=&quot;d.jsp&quot;/&gt;</span><br><br><p><p><pre name="code" class="html">d.jsp
&lt;%@ page contentType=&quot;text/html; charset=GBK&quot; %&gt;
&lt;html&gt;
&lt;body bgcolor=&quot;#ffffff&quot;&gt;
requestB-C的魔爪已经伸到了d.jsp页面
&lt;%
out.println(&quot;age=&quot; + request.getParameter(&quot;age&quot;));
%&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre><br><p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">运行程序，你会发现c页面中的内容没有显示出来，因为forward是自动执行的，地址栏中虽然是c.jsp但实际上，但浏览器中显示的已经是d.jsp的 内容了，而且看到了从b.jsp传过来的参数。你可以简单得这样理解：转发，就是延长了requestB-C的作用 域，&lt;jsp:forwardpage=&quot;d.jsp&quot;/&gt;，这一句话实际上是把c.jsp和d.jsp粘到了一起，他们就像是在一个页面 中。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>如果你用过struts，那么你就知道为什么在Action中，最后一句几乎总是mapping.findForward(&quot;xxx&quot;);了。因为我们在这个Action中设置的请求作用域的变量都将会在下一个页面（也许是另一个Action）中用到，所以要用转发。</span></p><br><h1><span style="font-family:KaiTi_GB2312;font-size:18px;"><strong>总结：</strong></span></h1><p><br></p><p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">下面是<strong>HttpServletResponse.sendRedirect</strong> 方法实现的请求重定向与<strong>RequestDispatcher.forward</strong> 方法实现的请求转发的总结比较：</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>（1）RequestDispatcher.forward 方法只能将请求转发给同一个WEB应用中的组件；而HttpServletResponse.sendRedirect 方法不仅可以重定向到当前应用程序中的其他资源，还可以重定向到同一个站点上的其他应用程序中的资源，甚至是使用绝对URL重定向到其他站点的资源，例如重定向到百度的网址。如果传递给HttpServletResponse.sendRedirect 方法的相对URL以“/”开头，它是相对于整个WEB站点的根目录；如果创建RequestDispatcher 对象时指定的相对URL以“/”开头，它是相对于当前WEB应用程序的根目录。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">对于重定向来说，有时我们controller的方法返回的是字符串类型数据，那么如果我们需要重定向我们可以如下操作：</span></p><p><pre name="code" class="java">response.sendRedirect(&quot;http://www.baidu.com&quot;); 
return null;</pre><p><br></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">（2）调用HttpServletResponse.sendRedirect 方法重定向的访问过程结束后，浏览器地址栏中显示的URL会发生改变，由初始的URL地址变成重定向的目标URL；而调用 RequestDispatcher.forward 方法的请求转发过程结束后，浏览器地址栏保持初始的URL地址不变。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>（3）HttpServletResponse.sendRedirect 方法对浏览器的请求直接作出响应，响应的结果就是告诉浏览器去重新发出对另外一个URL的访问请求。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>举个例子：重定向过程好比有个绰号叫“浏览器”的人写信找张三借钱，张三回信说没有钱，让“浏览器”去找李四借，并将李四现在的通信地址告诉给了“浏览器 ”。于是，“浏览器”又按张三提供通信地址给李四写信借钱，李四收到信后就把钱汇给了“浏览器”。可见，“浏览器”一共发出了两封信和收到了两次回复，“ 浏览器”也知道他借到的钱出自李四之手。 RequestDispatcher.forward 方法在服务器端内部将请求转发给另外一个资源，浏览器只知道发出了请求并得到了响应结果，并不知道在服务器程序内部发生了转发行为。这个过程好比绰号叫“ 浏览器”的人写信找张三借钱，张三没有钱，于是张三找李四借了一些钱，甚至还可以加上自己的一些钱，然后再将这些钱汇给了“浏览器”。可见，“浏览器”只 发出了一封信和收到了一次回复，他只知道从张三那里借到了钱，并不知道有一部分钱出自李四之手。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>（4）RequestDispatcher.forward 方法的调用者与被调用者之间共享相同的request 对象和response 对象，它们属于同一个访问请求和响应过程；而HttpServletResponse.sendRedirect 方法调用者与被调用者使用各自的request 对象和response 对象，它们属于两个独立的访问请求和响应过程。<br>对于同一个WEB应用程序的内部资源之间的跳转，特别是跳转之前要对请求进行一些前期预处理，并要使用 HttpServletRequest.setAttribute 方法传递预处理结果，那就应该使用RequestDispatcher.forward 方法。<br>不同WEB应用程序之间的重定向，特别是要重定向到另外一个WEB站点上的资源的情况，都应该使HttpServletResponse.sendRedirect 方法。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>（5）无论是RequestDispatcher.forward 方法，还是HttpServletResponse.sendRedirect 方法，在调用它们之前，都不能有内容已经被实际输出到了客户端。如果缓冲区中已经有了一些内容，这些内容将被从缓冲区中清除。</span></p><br><p><br></p><p><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/49977793'>原文链接</a>