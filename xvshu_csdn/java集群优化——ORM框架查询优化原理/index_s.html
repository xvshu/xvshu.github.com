<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; java集群优化——ORM框架查询优化原理</div><div style="color:blue" align=center>java集群优化——ORM框架查询优化原理</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 众所周知，当下的流行的企业级架构中，ORM一直是最基础的部分，在架构设计的底层，对逻辑层提供面向对象的操作支持，而事实总是和我们预想的有所偏差，ORM在提供了较好的操作体验时，也流失了一部分原生SQL的灵活性与高效性，当然，这个问题不影响我们使用ORM框架，但是却阻碍了我们网站流量的提升，尤其是在企业级的多关系复杂查询方面，性能瓶颈是不得不提的部分！</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 针对此问题，大多数的ORM框架提供一个折中的解决方案，就是在查询语句中，构造一个对象，可以是一个Entity，也可以是Map等，这样的方案，很大程度上解决了级联查询的问题，今天，我们一起来揭开这层面纱，看看这里的优化，是如何做到的！</span></p>
<h1><span style="font-size:18px">现象： &nbsp; &nbsp; &nbsp; &nbsp;</span></h1>
<p><span style="font-size:18px">先看看我们的实验中用到的几个实体</span></p>
<p><span style="font-size:18px"><img src="29578469861602" alt=""><br>
</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px">大家可以看到中间的学生实体，和其他的实体关联太多，如果我们使用一般的查询语句会变得非常缓慢，我们测试在查询10条记录，不开启懒加载的前提下，10分钟这些数据都不能加载，大家看看日志文件，发的sql语句：</span></p>
<h1><span style="font-size:18px">原因</span></h1>
<p><span style="font-size:18px">查询语句：</span></p>
<p><span style="font-size:18px">From Student &nbsp;where isDlete=0&nbsp;</span></p>
<p><span style="font-size:18px">日志文件：</span></p>
<p><span style="font-size:18px"><img src="50001008706232" alt=""><br>
</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 这只是一小部分，我们做的统计是，发出了241条查询语句，这样的结果是客户不能容忍的，通过研究，我们发现直接发 from 虽然可以返回对象，但是严重拖慢查询效率，在from前加select语句，就会好很多，因为加上select后，就会组合成join语句，最后只发一天sql语句，对效率的提升是明显的！</span></p>
<h1><span style="font-size:18px">总结：</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 一个问题的解决方法，有时候会非常简单，而又对自己当初的设计懊悔不已，其实这都是一个过程，一个财富，我们遇到的每一个问题，都是为了让我们在以后的设计中有更好的想法，当然更重要的一点就是那别人撞的头破血流的经验作为自己的经验，提升自己的能力，这也是企业喜欢见到的！</span></p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/46983017'>原文链接</a>