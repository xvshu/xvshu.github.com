<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; 项目修炼之路（5）高并发下优化Redis缓存效率</div><div style="color:blue" align=center>项目修炼之路（5）高并发下优化Redis缓存效率</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 最近，公司给了个优化任务，某个耗时的操作，在百亿的交易额下，处理异常缓慢，需要优化，以为每日发息做准备，在这里给大家介绍下我的优化思路，共同探讨下：</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px">代码逻辑：</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 通过用户id获取用户所在区域id，每次批量处理1千个用户，起20个线程处理。</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">第一步，加缓存</span></h1>
<p><span style="font-size:18px">通过用户id获取用户所在区域id分两步实现（代码中已经标红），第一步通过用户获取城市id，第二部通过城市id获取区域id，使用上篇博客介绍的方法（<a target="_blank" target="_blank" href="http://blog.csdn.net/xvshu/article/details/50681026">项目修炼之路（4）aop&#43;注解的自动缓存</a>），给两个方法加入redis缓存。<br>
</span></p>
<p>
<pre name="code" class="javascript">@Override
	public PublicResult&lt;HashMap&lt;Integer, Integer&gt;&gt; getUserAreaFranchiseeIDS(List&lt;Integer&gt; uids) {
		PublicResult&lt;HashMap&lt;Integer, Integer&gt;&gt; result = new PublicResult&lt;HashMap&lt;Integer, Integer&gt;&gt;();
		HashMap&lt;Integer, Integer&gt; resultMap = new HashMap&lt;Integer, Integer&gt;();

		long time;
		for(Integer uid :uids){
			Integer areaId = Integer.valueOf(0);
			try {
				time=System.currentTimeMillis();
				UserAreaFranchisee area =getUserAreaFranchisee(uid).getResult();
				LOGGER.info(&quot;=getUserAreaFranchiseeIDS=&gt;--.uid:[&quot;+uid+&quot;].[get -- wmpsDayInterChange]getUserAreaFranchisee() -------------spen time:&quot; + (System.currentTimeMillis()-time));
				time=System.currentTimeMillis();
				int id = 0;
				if (area != null &amp;&amp; area.getCityid() != null &amp;&amp; area.getCityid().intValue() &gt; 0) {
					id = area.getCityid().intValue();
					 tpr = logicTongchengAreaService.getTongchengArea(Integer.valueOf(id));
					if (tpr != null &amp;&amp; tpr.isSuccess() &amp;&amp; tpr.getResult() != null &amp;&amp; tpr.getResult().getId() != null &amp;&amp; tpr.getResult().getId() &gt; 0) {
						areaId = tpr.getResult().getId();
					}
				}
				LOGGER.info(&quot;=getUserAreaFranchiseeIDS=&gt;--..uid:[&quot;+uid+&quot;].[get -- wmpsDayInterChange]getLogicTongchengAreaService() -------------spen time:&quot; + (System.currentTimeMillis()-time));

			}catch (Exception e){
				LOGGER.error(&quot;=getUserAreaFranchiseeIDS=&gt;&quot;,e);
			}
			resultMap.put(uid,areaId);
		}


		result.setSuccess(true);
		result.setResult(resultMap);
		return result;
	}</pre><br>
<br>
<p>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">第二步，合并结果</span></h1>
<p><span style="font-size:18px">问题：加入缓存后，发现，当访问频繁时，两次访问加入的缓存不合理：1，value为对象，给每次取&#20540;增加反序列化过程，实际只需id即可；2,两次操作，最终只需一个结果，造成资源浪费。</span></p>
<p><span style="font-size:18px">优化后：二次缓存变为一次缓存，key与value均为简单string与Integer<br>
</span></p>
<p>
<pre code_snippet_id="1580792" snippet_file_name="blog_20160217_2_2707963" name="code" class="java">@Override
	public PublicResult&lt;String&gt; getUserAreaFranchiseeIDS(ArrayList&lt;Integer&gt; uids) {
		PublicResult&lt;String&gt; result = new PublicResult&lt;String&gt;();
		HashMap&lt;Integer, Integer&gt; resultMap = new HashMap&lt;Integer, Integer&gt;();
		long time;
		for(Integer uid :uids){
			Integer areaId = Integer.valueOf(0);
			try {
				time=System.currentTimeMillis();
				areaId = userAreaFranchiseeService.getUserAreaIdByUid(uid);
				LOGGER.info(&quot;=getUserAreaFranchiseeIDS=&gt;--.uid:[&quot; + uid + &quot;].[get -- wmpsDayInterChange]getUserAreaIdByUid() -------------spen time:&quot; + (System.currentTimeMillis() - time));
			}catch (Exception e){
				LOGGER.error(&quot;=getUserAreaFranchiseeIDS=&gt;&quot;,e);
			}
			resultMap.put(uid,areaId);
		}
		result.setSuccess(true);
		result.setResult(JSON.toJSONString(resultMap));
		return result;
	}</pre>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<h1><span style="font-size:18px">第三步：批量读取</span></h1>
<p><span style="font-size:18px">问题：redis为单线程，批量数据访问时，单个从redis拿数据的时间被延长，造成时间上的浪费，而且，浪费在网络上的时间比读数据时间要长<br>
</span></p>
<p><span style="font-size:18px">优化后：批量从redis获取一次获取，多次io改为一次io，拿不到的数据，才从数据库中读取，同时缓存到redis。</span></p>
<p>
<pre code_snippet_id="1580792" snippet_file_name="blog_20160217_3_5597902" name="code" class="java">@Override
	public PublicResult&lt;String&gt; getUserAreaFranchiseeIDS(ArrayList&lt;Integer&gt; uids) {
		PublicResult&lt;String&gt; result = new PublicResult&lt;String&gt;();
		HashMap&lt;Integer, Integer&gt; resultMap = new HashMap&lt;Integer, Integer&gt;();
		long time;
		ArrayList&lt;String&gt; uidKeys = new ArrayList&lt;String&gt;();
		for(int i=0;i&lt;uids.size();i++){
			uidKeys.add(i,RedisKeyUtils.USER_AREA_ID+ uids.get(i));
		}
		List&lt;Integer&gt; listAreas = RedisUtils.mget(uidKeys.toArray(),Integer.class);
		for(int i=0 ;i&lt;uids.size();i++){
			Integer uid = uids.get(i);
			Integer areaId = Integer.valueOf(0);
			if(listAreas.get(i)==null){
				try {
					time=System.currentTimeMillis();
					areaId = userAreaFranchiseeService.getUserAreaIdByUid(uid);
					LOGGER.info(&quot;=getUserAreaFranchiseeIDS=&gt;--.uid:[&quot; + uid + &quot;].[get -- wmpsDayInterChange]getUserAreaIdByUid() -------------spen time:&quot; + (System.currentTimeMillis() - time));

				}catch (Exception e){
					LOGGER.error(&quot;=getUserAreaFranchiseeIDS=&gt;error uid:[&quot;+uid+&quot;]&quot;,e);
				}
				listAreas.set(i,areaId);
			}
			areaId = listAreas.get(i);
			resultMap.put(uid,areaId);
		}
		result.setSuccess(true);
		result.setResult(JSON.toJSONString(resultMap));
		return result;
	}</pre>
<p>
<p><span style="font-size:18px"><br>
</span></p>
<span style="font-size:18px"><br>
</span>
<h1><span style="font-size:18px">第四步：批量添加</span></h1>
<p><span style="font-size:18px">问题：设置缓存周期后，每隔一段时间，读取数据几乎全从数据库读取，加上增加到redis的时间，会造成周期性读取缓慢。<br>
</span></p>
<p><span style="font-size:18px">优化后：时间限制拉长，判断是否能从redis获取一半的数据，如果不能，批量将数据缓存到redis（一次io），再走逻辑</span></p>
<p>
<pre code_snippet_id="1580792" snippet_file_name="blog_20160217_4_1344760" name="code" class="java">@Override
	public PublicResult&lt;String&gt; getUserAreaFranchiseeIDS(ArrayList&lt;Integer&gt; uids) {
		PublicResult&lt;String&gt; result = new PublicResult&lt;String&gt;();
		HashMap&lt;Integer, Integer&gt; resultMap = new HashMap&lt;Integer, Integer&gt;();
		long time;
		ArrayList&lt;String&gt; uidKeys = new ArrayList&lt;String&gt;();
		for(int i=0;i&lt;uids.size();i++){
			uidKeys.add(i,RedisKeyUtils.USER_AREA_ID+ uids.get(i));
		}
		List&lt;Integer&gt; listAreas = RedisUtils.mget(uidKeys.toArray(),Integer.class);

		try {
			if (ListUtil.countNullNumber(listAreas) &gt; listAreas.size() / 2) {
				initRedisByUids(uids);
				listAreas = RedisUtils.mget(uidKeys.toArray(), Integer.class);
			}
		}catch (Exception e){
			LOGGER.error(&quot;=getUserAreaFranchiseeIDS=&gt;initRedisByUids error&quot;,e);
		}

		for(int i=0 ;i&lt;uids.size();i++){
			Integer uid = uids.get(i);
			Integer areaId = Integer.valueOf(0);
			if(listAreas.get(i)==null){
				try {
					time=System.currentTimeMillis();
					areaId = userAreaFranchiseeService.getUserAreaIdByUid(uid);
					LOGGER.info(&quot;=getUserAreaFranchiseeIDS=&gt;--.uid:[&quot; + uid + &quot;].[get -- wmpsDayInterChange]getUserAreaIdByUid() -------------spen time:&quot; + (System.currentTimeMillis() - time));

				}catch (Exception e){
					LOGGER.error(&quot;=getUserAreaFranchiseeIDS=&gt;error uid:[&quot;+uid+&quot;]&quot;,e);
				}
				listAreas.set(i,areaId);
			}
			areaId = listAreas.get(i);
			resultMap.put(uid,areaId);
		}
		result.setSuccess(true);
		result.setResult(JSON.toJSONString(resultMap));
		return result;
	}

	private boolean initRedisByUids(ArrayList&lt;Integer&gt; uids){
		boolean isSuccess = false;
		HashMap&lt;String, Integer&gt; resultMap =null;
		try {
			resultMap = ListUtil.getMaxAndMinInterger(uids);
			if(resultMap!=null &amp;&amp; !resultMap.isEmpty()){

				List&lt;UserAreaUidVo&gt; listResult = userAreaFranchiseeService.getUserAreaIdPageByUid(resultMap.get(ListUtil.minNumKey), resultMap.get(ListUtil.maxNumKey));
				if(listResult!=null &amp;&amp; !listResult.isEmpty()){
					HashMap&lt;String ,List&gt; hashMapForUid =uidToRedisKeyAndVlues(listResult);
					RedisUtils.mset(hashMapForUid.get(RedisKeys).toArray(),hashMapForUid.get(RedisValues).toArray(),RedisKeyUtils.USER_AREA_ID_TIME);
					isSuccess=true;
				}
			}
		}catch(Exception e){
			LOGGER.error(&quot;=initRedisByUids=&gt;&quot;,e);
		}

		return isSuccess;
	}

	private HashMap&lt;String ,List&gt; uidToRedisKeyAndVlues(List&lt;UserAreaUidVo&gt; listUserArea){
		HashMap&lt;String ,List&gt; hashMapForUid = new HashMap&lt;String ,List&gt;();
		List&lt;String&gt; keys = new ArrayList&lt;String&gt;(listUserArea.size());
		List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;(listUserArea.size());
		for(int i=0;i&lt;listUserArea.size();i++){
			keys.add( RedisKeyUtils.USER_AREA_ID + listUserArea.get(i).getUid());
			values.add(listUserArea.get(i).getAreaid() == null ? 0 : listUserArea.get(i).getAreaid());
		}
		hashMapForUid.put(RedisKeys,keys);
		hashMapForUid.put(RedisValues,values);
		return hashMapForUid;
	}</pre><span style="font-size:18px"><br>
</span>
<p>
<h1><span style="font-size:18px">总结：</span></h1>
<p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 在工作中，我们会遇到各种难题，实际这些难题，帮助我们提升了自己的解决问题能力外，还帮助我们制造了一种奇妙的东西，叫思路，或者叫框架，就是再有类&#20284;问题时，我们会映射过来，我是不是解决过，不仅仅局限在代码端，在生活和处理社会问题时，实际是相通的！</span></p>
<p><span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 所以，代码积累的不仅仅是工作经验，还有生活经验！</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px">附录：工具类：</span></p>
<p><span style="font-size:18px"></span></p>
<pre name="code" class="java">public class ListUtil {

    public static String maxNumKey =&quot;max&quot;;
    public static String minNumKey =&quot;min&quot;;
    /**
     * 按照某大小对list分页
     * @param targe
     * @param size
     * @return
     */
    public static List&lt;List&gt;  splitList(List targe,int size) {
        List&lt;List&gt; listArr = new ArrayList&lt;List&gt;();
        //获取被拆分的数组个数
        int arrSize = targe.size()%size==0?targe.size()/size:targe.size()/size+1;
        for(int i=0;i&lt;arrSize;i++) {
            List  sub = new ArrayList();
            //把指定索引数据放入到list中
            for(int j=i*size;j&lt;=size*(i+1)-1;j++) {
                if(j&lt;=targe.size()-1) {
                    sub.add(targe.get(j));
                }
            }
            listArr.add(sub);
        }
        return listArr;
    }

    /**
     * 统计list中为null的元素个数
     * @param listTest
     * @return
     */
   public static long countNullNumber(List listTest){
       long  count=0;
       for(int i=0;i&lt;listTest.size();i++){
           if(listTest.get(i)==null){
               count++;
           }
       }
       return count;
   }

    /**
     * 统计list中为null的元素个数
     * @param listTest
     * @return
     */
    public static HashMap getMaxAndMinInterger(List&lt;Integer&gt; listTest)throws Exception{
        if(listTest==null || listTest.isEmpty()){
            throw new Exception(&quot;=ListUtil.getMaxAndMinInterger=&gt; listTest is null&quot;);
        }
        HashMap&lt;String,Integer&gt; result = new HashMap&lt;String,Integer&gt;();
        Integer  maxNum=null;
        Integer minNum=null;
        for(int i=0;i&lt;listTest.size();i++){
            if(!(listTest.get(i)==null)){
                if(maxNum==null){
                    maxNum=listTest.get(i);
                }

                if(maxNum&lt;listTest.get(i)){
                    maxNum=listTest.get(i);
                }

                if(minNum==null){
                    minNum=listTest.get(i);
                }
                if(minNum&gt;listTest.get(i)){
                    minNum=listTest.get(i);
                }
            }
        }
        if(maxNum==null || minNum == null){
            throw new Exception(&quot;=ListUtil.getMaxAndMinInterger=&gt; listTest is null&quot;);
        }
        result.put(maxNumKey,maxNum);
        result.put(minNumKey,minNum);
        return result;
    }


}</pre><br>
<br>
<p>
<p><br>
</p>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/50681563'>原文链接</a>