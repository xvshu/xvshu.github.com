<div style="color:blue" align=center>外观,代理与中介者模式</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<h2><span style="font-family:KaiTi_GB2312; font-size:24px">外观模式</span></h2>
<div><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:24px">个人理解：</span></div>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp; 子类继承外观类的所有属性方法，客户端只需要跟外观类进行交流，实现了<span style="color:#cc0000">对所有子类的封装</span>。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">没有使用外观类</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">如图：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp;<img src="37223696997508.png" alt=""><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">应用外观类</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">如图：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<img src="29812919768933.png" alt="">&nbsp;</span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:24px">代理模式</span></h2>
<div><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></div>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">个人理解：</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 代理模式是<span style="color:#cc0000">将原类进行封装</span>，客户端只需要与代理进行交流。代理就是原类的一个替身。简而言之就是用一个对象代表另外一个对象。<span style="color:#cc0000">强调的是个体</span>。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:24px">中介者模式</span></h2>
<div><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; 定义一个中介对象来封装系列对象之间的交互。中介者使各个对象不需要显示地相互引用，从而使其耦合性松散，而且可以独立地改变他们之间的交互</span><br>
</div>
<p>
<p><span style="color:rgb(0,128,0)"><strong><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></strong></span></p>
<p><span style="color:rgb(0,128,0)"><strong><span style="font-family:KaiTi_GB2312; font-size:24px">使用中介者模式的场合</span></strong></span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">1.一组定义良好的对象，现在要进行复杂的通信。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">2.定制一个分布在多个类中的行为，而又不想生成太多的子类。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">可以看出，中介对象主要是用来封装行为的，行为的参与者就是那些对象，但是通过中介者，这些对象不用相互知道。</span></p>
<p><span style="color:rgb(0,128,0)"><strong><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></span></strong></span></p>
<p><span style="color:rgb(0,128,0)"><strong><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px">使用中介者模式的优点：</span></span></strong></span></p>
<p><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px">1.降低了系统对象之间的耦合性，使得对象易于独立的被复用。</span></span></p>
<p><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px">2.提高系统的灵活性，使得系统易于扩展和维护。</span></span></p>
<p><span style="color:rgb(0,128,0)"><strong><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></span></strong></span></p>
<p><span style="color:rgb(0,128,0)"><strong><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px">使用中介者模式的缺点：</span></span></strong></span></p>
<p><span style="line-height:24px"><span style="font-family:KaiTi_GB2312; font-size:24px">中介者模式的缺点是显而易见的，因为这个“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。</span></span></p>
<br>
<p><br>
</p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;三者的区别与联系</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px"><br>
</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">1，中介者模式：A，B之间的对话通过C来传达。A,B可以互相不认识（<span style="color:#cc0000">减少了A和B对象间的耦合</span>）</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">2，代理模式：A要送B&#31036;物，A,B互相不认识，那么A可以找C来帮它实现送&#31036;物的愿望（<span style="color:#cc0000">封装了A对象</span>）</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">3，外观模式：A和B都要实现送花，送巧克力的方法，那么我可以通过一个抽象类C实现送花送巧克力的方法（A和B都继承C）。（<span style="color:#cc0000">封装了A，B子类</span>）</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">代理模式和外观者模式这两种模式主要不同就是代理模式针对的是单个对象，而外观模式针对的是所有子类。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span></p>
<div><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp;&nbsp;</span></div>
<div><span style="font-family:KaiTi_GB2312; font-size:24px">&nbsp; &nbsp; &nbsp; &nbsp;</span></div>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/8450323'>原文链接</a>