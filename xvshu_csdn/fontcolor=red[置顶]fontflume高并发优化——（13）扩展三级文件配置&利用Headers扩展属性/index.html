<div style="color:blue" align=center>fontcolor=red[置顶]fontflume高并发优化——（13）扩展三级文件配置&利用Headers扩展属性</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 上篇博客中，我们对flume进行了文件组进行了扩展，但是我们现在的配置还是针对某组文件单独配置，这样的维护成本还是太高，为了持续优化，我们对常见的三级文件进行优化（**logs/**project/**type/*.log）利用公司内部的约定，大家一起为简单配置努力。</span></p><h1><span style="font-size:18px;">1，规范目录结构</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 在本项目约定下，日志结构采取如下：</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; /logs/*project/type-tomcat/*.log</span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">2，抽象日志配置</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在这个配置下，我们抽象成两级配置：</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第一级：根目录</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;/logs<br></span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第二级：业务目录</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;/*project<br></span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;第三级：类型目录（不可扩展）</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;一般为业务日志，数据日志</span></p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; source config</span></p><p><span style="font-size:18px;"></span></p><pre name="code" class="html">agent1.sources.s1.type = org.apache.flume.source.ExecTailSource
agent1.sources.s1.basefilepath=/export/home/tomcat/logs
agent1.sources.s1.filepath=account.soa|user.soa
agent1.sources.s1.apilogs=all
agent1.sources.s1.operatelogs=no
agent1.sources.s1.tomcatlogs=no
agent1.sources.s1.tailing=all
agent1.sources.s1.filenameRegExp=(.log{1})$
agent1.sources.s1.readinterval=300
agent1.sources.s1.startAtBeginning=false
agent1.sources.s1.restart=true
agent1.sources.s1.contextIsJson=false
agent1.sources.s1.contextIsFlumeLog=true</pre><br><br><p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">3，Headers定制sink</span></h1><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;3.1 elasticsearch sink</span></h2><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;indexType：The type to index the document to, defaults to ‘log’ Arbitrary header substitution is supported, eg. %{header} replaces with value of named event header。<br></span></p><p><span style="font-size:18px;"><br></span></p><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;3.2 kafka sink</span></h2><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;topic：The topic in Kafka to which the messages will be published. If this parameter is configured, messages will be published to this topic. If the event header contains a “topic” field, the event will be published to that topic overriding the topic configured here.<br></span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">4，demo</span></h1><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;4.1 elasticsearch sink config &amp; set headers</span></h2><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;flume config</span></p><p><pre name="code" class="html"><span style="font-size:18px;">agent1.sinks.k1.type=org.apache.flume.sink.elasticsearch.ElasticSearchSink
agent1.sinks.k1.batchSize=5000
agent1.sinks.k1.hostNames=192.168.2.16:9300
agent1.sinks.k1.indexType =log_file_tender
agent1.sinks.k1.indexName=logstash_test
agent1.sinks.k1.clusterName=unifyloggingplatform
agent1.sinks.k1.serializer=org.apache.flume.sink.elasticsearch.ElasticSearchLogStashEventSerializer
agent1.sinks.k1.indexNameBuilder=org.apache.flume.sink.elasticsearch.TimeBasedIndexNameBuilder
agent1.sinks.k1.dateFormat=dd</span></pre><span style="font-size:18px;"><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;set headers</span><p><p><pre name="code" class="java"><span style="font-size:18px;"> Event oneEvent = EventBuilder.withBody(bodyjson.getBytes(charset));
 oneEvent.getHeaders().put(&quot;UlogDomain&quot;,domain);</span></pre><span style="font-size:18px;"><br></span><p><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;4.2 kafka sink config &amp; set headers</span></h2><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;flume config<br></span></p><p><pre code_snippet_id="1924464" snippet_file_name="blog_20161012_3_3760208" name="code" class="html"><span style="font-size:18px;">a1.sinks.k1.type = org.apache.flume.sink.kafka.KafkaSink
a1.sinks.k1.topic = mytopic
a1.sinks.k1.brokerList = localhost:9092
a1.sinks.k1.requiredAcks = 1
a1.sinks.k1.batchSize = 20
a1.sinks.k1.channel = c1</span></pre><span style="font-size:18px;"><br></span><p><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;set headers<br></span></p><p><pre code_snippet_id="1924464" snippet_file_name="blog_20161012_4_3596675" name="code" class="java"><span style="font-size:18px;"> Event oneEvent = EventBuilder.withBody(bodyjson.getBytes(charset));
 oneEvent.getHeaders().put(&quot;UlogDomain&quot;,domain);
 oneEvent.getHeaders().put(&quot;topic&quot;,&quot;file_channel_topic_&quot;+domain);</span></pre><span style="font-size:18px;"><br></span><p><h1><span style="font-size:18px;">总结：</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;在全局的消息体中，保留一个map，让用户自定义，以便在后期的配置中，预留对象，这种设计思想，既满足了灵活又满足了规范，我们在以后的设计中，也要充分借鉴，为用户想到用户想要的，给用户留下用户以后想加入的，方便用户扩展！</span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;">全局代码实现：</span></p><p><span style="font-size: 18px;">项目地址：https://github.com/xvshu/flume-files-source</span></p><p><pre code_snippet_id="1924464" snippet_file_name="blog_20161012_5_1961255" name="code" class="java"><span style="font-size:18px;">/*
 * 作者：许恕
 * 时间：2016年5月3日
 * 功能：实现tail 某目录下的所有符合正则条件的文件
 * Email：xvshu1@163.com
 * To detect all files in a folder
 */

package org.apache.flume.source;

import com.dianping.cat.Cat;
import com.dianping.cat.message.Transaction;
import com.el.ump.profiler.Profiler;
import com.google.common.base.Preconditions;
import com.google.common.util.concurrent.ThreadFactoryBuilder;
import org.apache.flume.Context;
import org.apache.flume.Event;
import org.apache.flume.EventDrivenSource;
import org.apache.flume.SystemClock;
import org.apache.flume.channel.ChannelProcessor;
import org.apache.flume.conf.Configurable;
import org.apache.flume.event.EventBuilder;
import org.apache.flume.instrumentation.SourceCounter;
import org.apache.flume.source.utils.MsgBuildeJson;
import org.mortbay.util.ajax.JSON;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.nio.charset.Charset;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 *  step：
 *    1,config one path
 *    2,find all file with RegExp
 *    3,tail one children file
 *    4,batch to channal
 *
 *  demo:
 *    demo.sources.s1.type = org.apache.flume.source.ExecTailSource
 *    demo.sources.s1.filepath=/export/home/tomcat/logs/auth.el.net/
 *    demo.sources.s1.filenameRegExp=(.log{1})$
 *    demo.sources.s1.tailing=true
 *    demo.sources.s1.readinterval=300
 *    demo.sources.s1.startAtBeginning=false
 *    demo.sources.s1.restart=true
 */
public class ExecTailSource extends AbstractSource implements EventDrivenSource,
        Configurable {

  private static final Logger logger = LoggerFactory
          .getLogger(ExecTailSource.class);

  private SourceCounter sourceCounter;
  private ExecutorService executor;
  private List&lt;ExecRunnable&gt; listRuners;
  private List&lt;Future&lt;?&gt;&gt; listFuture;
  private long restartThrottle;
  private boolean restart = true;
  private boolean logStderr;
  private Integer bufferCount;
  private long batchTimeout;
  private Charset charset;
  private String  basefilepath;
  private String filepath;
  private String filenameRegExp;

  private String apilogs;
  private String operatelogs;
  private String tomcatlogs;

  private List&lt;String&gt; apilogsList = new ArrayList&lt;String&gt;();
  private List&lt;String&gt; operatelogsList = new ArrayList&lt;String&gt;();
  private List&lt;String&gt; tomcatlogsList =  new ArrayList&lt;String&gt;();

  private String tailing;
  private Integer readinterval;
  private boolean startAtBeginning;
  private boolean contextIsJson;
  private String fileWriteJson;
  private Long flushTime;
  private boolean contextIsFlumeLog;
  private String domain;
  private String msgTypeConfig;


  @Override
  public void start() {
    logger.info(&quot;=start=&gt; flume tail source start begin time:&quot;+new Date().toString());
    logger.info(&quot;ExecTail source starting with filepath:{}&quot;, filepath);

    List&lt;String&gt; listFiles = getFileList();
    if(listFiles==null || listFiles.isEmpty()){
      logger.info(&quot;The filepath's file not have fiels with filenameRegExp&quot;);
      sourceCounter.start();
      super.start();
      return;
    }

    Properties prop=null;

    try{
      prop = new Properties();//属性集合对象
      FileInputStream fis = new FileInputStream(fileWriteJson);//属性文件流
      prop.load(fis);
    }catch(Exception ex){
      logger.error(&quot;==&gt;&quot;,ex);
    }



    executor = Executors.newFixedThreadPool(listFiles.size());

    listRuners = new ArrayList&lt;ExecRunnable&gt;();
    listFuture = new ArrayList&lt;Future&lt;?&gt;&gt;();

    logger.info(&quot;files size is {} &quot;, listFiles.size());
    // FIXME: Use a callback-like executor / future to signal us upon failure.
    for(String oneFilePath : listFiles){
      ExecRunnable runner = new ExecRunnable(getChannelProcessor(), sourceCounter,
              restart, restartThrottle, logStderr, bufferCount, batchTimeout,
              charset,oneFilePath,tailing,readinterval,startAtBeginning,contextIsJson,
              prop,fileWriteJson,flushTime,contextIsFlumeLog,domain);
      listRuners.add(runner);
      Future&lt;?&gt; runnerFuture = executor.submit(runner);
      listFuture.add(runnerFuture);
      logger.info(&quot;{} is begin running&quot;,oneFilePath);
    }

    /*
     * NB: This comes at the end rather than the beginning of the method because
     * it sets our state to running. We want to make sure the executor is alive
     * and well first.
     */
    sourceCounter.start();
    super.start();
    logger.info(&quot;=start=&gt; flume tail source start end time:&quot;+new Date().toString());
    logger.debug(&quot;ExecTail source started&quot;);
  }

  @Override
  public void stop() {

    logger.info(&quot;=stop=&gt; flume tail source stop begin time:&quot;+new Date().toString());
    if(listRuners !=null &amp;&amp; !listRuners.isEmpty()){
      for(ExecRunnable oneRunner : listRuners){
        if(oneRunner != null) {
          oneRunner.setRestart(false);
          oneRunner.kill();
        }
      }
    }


    if(listFuture !=null &amp;&amp; !listFuture.isEmpty()){
      for(Future&lt;?&gt; oneFuture : listFuture){
        if (oneFuture != null) {
          logger.debug(&quot;Stopping ExecTail runner&quot;);
          oneFuture.cancel(true);
          logger.debug(&quot;ExecTail runner stopped&quot;);
        }
      }
    }

    executor.shutdown();
    while (!executor.isTerminated()) {
      logger.debug(&quot;Waiting for ExecTail executor service to stop&quot;);
      try {
        executor.awaitTermination(500, TimeUnit.MILLISECONDS);
      } catch (InterruptedException e) {
        logger.debug(&quot;Interrupted while waiting for ExecTail executor service &quot;
                + &quot;to stop. Just exiting.&quot;);
        Thread.currentThread().interrupt();
      }
    }




    sourceCounter.stop();
    super.stop();
    logger.info(&quot;=stop=&gt; flume tail source stop end time:&quot;+new Date().toString());

  }

  @Override
  public void configure(Context context) {

    basefilepath=context.getString(ExecTailSourceConfigurationConstants.BASE_FILE_PATH,
            ExecTailSourceConfigurationConstants.DEFAULT_BASE_FILE_PATH);

    filepath = context.getString(&quot;filepath&quot;);
    Preconditions.checkState(filepath != null,
            &quot;The parameter filepath must be specified&quot;);
    logger.info(&quot;The parameter filepath is {}&quot; ,filepath);

    apilogs = context.getString(ExecTailSourceConfigurationConstants.APILOGS,
            ExecTailSourceConfigurationConstants.DEFAULT_CHILDREN_FILE);

    apilogsList.addAll(Arrays.asList(apilogs.split(&quot;\\|&quot;)));

    operatelogs = context.getString(ExecTailSourceConfigurationConstants.OPERATELOGS,
            ExecTailSourceConfigurationConstants.DEFAULT_CHILDREN_FILE);
    operatelogsList.addAll(Arrays.asList(operatelogs.split(&quot;\\|&quot;)));

    tomcatlogs = context.getString(ExecTailSourceConfigurationConstants.TOMCATLOGS,
            ExecTailSourceConfigurationConstants.DEFAULT_CHILDREN_FILE);
    tomcatlogsList.addAll(Arrays.asList(tomcatlogs.split(&quot;\\|&quot;)));

    filenameRegExp = context.getString(&quot;filenameRegExp&quot;);
    Preconditions.checkState(filenameRegExp != null,
            &quot;The parameter filenameRegExp must be specified&quot;);
    logger.info(&quot;The parameter filenameRegExp is {}&quot; ,filenameRegExp);

    msgTypeConfig=context.getString(ExecTailSourceConfigurationConstants.CONFIG_MSGTYPECONFIG_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_MSGTYPECONFIG);

    String[] defultTypes = ExecTailSourceConfigurationConstants.DEFAULT_MSGTYPECONFIG_DEFULT.split(&quot;\\,&quot;);
    for(String oneType : defultTypes){
      String[] oneTypeMap = oneType.split(&quot;\\:&quot;);
      MsgBuildeJson.MsgTypes.put(oneTypeMap[0],oneTypeMap[1].split(&quot;\\|&quot;));
    }

    try {
      if (msgTypeConfig != null &amp;&amp; !msgTypeConfig.trim().isEmpty()) {
        String[] userTypes = msgTypeConfig.split(&quot;\\,&quot;);
        for(String oneType : defultTypes){
          String[] oneTypeMap = oneType.split(&quot;\\:&quot;);
          if(oneTypeMap.length&gt;=2){
            MsgBuildeJson.MsgTypes.put(oneTypeMap[0],oneTypeMap[1].split(&quot;\\|&quot;));
          }
        }
      }
    }catch (Exception ex){
      ex.printStackTrace();
    }

    logger.info(&quot;=MsgBuildeJson.MsgTypes is =&gt;&quot;+ JSON.toString(MsgBuildeJson.MsgTypes));


    MsgBuildeJson.MsgIntAtti.addAll(Arrays.asList(ExecTailSourceConfigurationConstants.MAP_INT_ATTRIBUTE.split(&quot;\\,&quot;)));

    contextIsJson= context.getBoolean(ExecTailSourceConfigurationConstants.CONFIG_CONTEXTISJSON_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_CONTEXTISJSON);

    contextIsFlumeLog=context.getBoolean(ExecTailSourceConfigurationConstants.CONFIG_CONTEXTISFLUMELOG_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_CONTEXTISFLUMELOG);

    domain=context.getString(ExecTailSourceConfigurationConstants.CONFIG_DOMIAN_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_DOMAIN);

    fileWriteJson= context.getString(ExecTailSourceConfigurationConstants.CONFIG_FILEWRITEJSON_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_FILEWRITEJSON);

    flushTime= context.getLong(ExecTailSourceConfigurationConstants.CONFIG_FLUSHTIME_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_FLUSHTIME);

    restartThrottle = context.getLong(ExecTailSourceConfigurationConstants.CONFIG_RESTART_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_RESTART_THROTTLE);

    tailing = context.getString(ExecTailSourceConfigurationConstants.CONFIG_TAILING_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_ISTAILING_TRUE);

    readinterval=context.getInteger(ExecTailSourceConfigurationConstants.CONFIG_READINTERVAL_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_READINTERVAL);

    startAtBeginning=context.getBoolean(ExecTailSourceConfigurationConstants.CONFIG_STARTATBEGINNING_THROTTLE,
            ExecTailSourceConfigurationConstants.DEFAULT_STARTATBEGINNING);

    restart = context.getBoolean(ExecTailSourceConfigurationConstants.CONFIG_RESTART,
            ExecTailSourceConfigurationConstants.DEFAULT_RESTART_TRUE);

    logStderr = context.getBoolean(ExecTailSourceConfigurationConstants.CONFIG_LOG_STDERR,
            ExecTailSourceConfigurationConstants.DEFAULT_LOG_STDERR);

    bufferCount = context.getInteger(ExecTailSourceConfigurationConstants.CONFIG_BATCH_SIZE,
            ExecTailSourceConfigurationConstants.DEFAULT_BATCH_SIZE);

    batchTimeout = context.getLong(ExecTailSourceConfigurationConstants.CONFIG_BATCH_TIME_OUT,
            ExecTailSourceConfigurationConstants.DEFAULT_BATCH_TIME_OUT);

    charset = Charset.forName(context.getString(ExecTailSourceConfigurationConstants.CHARSET,
            ExecTailSourceConfigurationConstants.DEFAULT_CHARSET));


    if (sourceCounter == null) {
      sourceCounter = new SourceCounter(getName());
    }
  }

  /**
   * 获取指定路径下的所有文件列表
   *
   * @return
   */
  public  List&lt;String&gt; getFileList() {
    List&lt;String&gt; fatherFilesList = new ArrayList&lt;String&gt;();
    List&lt;String&gt; listFile = new ArrayList&lt;String&gt;();
    String[] baseFatherFiles =basefilepath.split(&quot;\\|&quot;);
    for(String  oneBaseFile : baseFatherFiles){
      fatherFilesList.addAll(getPassDomainDir(oneBaseFile));
    }
    logger.info(&quot;=getFileList=&gt; fatherfiles is &quot;+JSON.toString(fatherFilesList));
    if(fatherFilesList != null || fatherFilesList.size()&gt;0){
      for(String oneDir :fatherFilesList ){
        listFile.addAll(getChildrenFileList(oneDir));
      }
    }
    return listFile;
  }

  public List&lt;String&gt; getPassDomainDir(String dir){
    String[] passFileNames = filepath.split(&quot;\\|&quot;);
    List&lt;String&gt; listReturn  =  new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; PassFileListName = new ArrayList&lt;String&gt;(Arrays.asList(passFileNames));
    File dirFile = new File(dir);
    File[] files = dirFile.listFiles();
    for(File oneCheckfile :files ){
      if(PassFileListName.contains(&quot;all&quot;)){
        listReturn.addAll(getFilesByConfig(oneCheckfile.getAbsolutePath()));
      } else if(PassFileListName.contains(getDomainName(oneCheckfile.getAbsolutePath()))){
        listReturn.addAll(getFilesByConfig(oneCheckfile.getAbsolutePath()));
      }
    }
    return listReturn;
  }

  private List&lt;String&gt;  getFilesByConfig(String dir){
    List&lt;String&gt; listReturn  =  new ArrayList&lt;String&gt;();
    String apiFile =  getPassApiDir(dir);
    String operateFile =  getPassOperateDir(dir);
    String tomcatFile =  getPassTomcatDir(dir);


    if(apiFile != null &amp;&amp; !apiFile.isEmpty()){
      listReturn.add(apiFile);
    }
    if(operateFile != null &amp;&amp; !operateFile.isEmpty()){
      listReturn.add(operateFile);
    }
    if(tomcatFile != null &amp;&amp; !tomcatFile.isEmpty()){
      listReturn.add(tomcatFile);
    }
    return listReturn;
  }

  public String getPassApiDir(String dir){
    if(apilogsList.contains(&quot;all&quot;)){
      dir+=&quot;/apilogs&quot;;
    }else if(apilogsList.contains( getDomainName(dir))){
      dir+=&quot;/apilogs&quot;;
    }else{
      return null;
    }

    return dir;
  }

  public String getPassOperateDir(String dir){
    if(operatelogsList.contains(&quot;all&quot;)){
      dir+=&quot;/operatelogs&quot;;
    }else if(operatelogsList.contains( getDomainName(dir))){
      dir+=&quot;/operatelogs&quot;;
    }else{
      return null;
    }
    return dir;
  }

  public String getPassTomcatDir(String dir){
    if(tomcatlogsList.contains(&quot;all&quot;)){
      dir+=&quot;/tomcatlogs&quot;;
    }else if(tomcatlogsList.contains( getDomainName(dir))){
      dir+=&quot;/tomcatlogs&quot;;
    }else{
      return null;
    }
    return dir;
  }

  private static String getDomainName(String filePath){
    String[] strs = filePath.split(&quot;/&quot;);
    String domain ;
    domain=strs[strs.length-1];
    if(domain==null || domain.isEmpty()){
      domain=filePath;
    }
    return domain;
  }

  public  List&lt;String&gt; getChildrenFileList(String dir){

      List&lt;String&gt; listFile = new ArrayList&lt;String&gt;();
      File dirFile = new File(dir);
      //如果不是目录文件，则直接返回
      if (dirFile.isDirectory()) {
        //获得文件夹下的文件列表，然后根据文件类型分别处理
        File[] files = dirFile.listFiles();
        if (null != files &amp;&amp; files.length &gt; 0) {
          //根据时间排序
          Arrays.sort(files, new Comparator&lt;File&gt;() {
            public int compare(File f1, File f2) {
              return (int) (f1.lastModified() - f2.lastModified());
            }

            public boolean equals(Object obj) {
              return true;
            }
          });
          for (File file : files) {
            //如果不是目录，直接添加
            if (!file.isDirectory()) {
              String oneFileName = file.getName();
              if(match(filenameRegExp,oneFileName)){
                listFile.add(file.getAbsolutePath());
                logger.info(&quot;filename:{} is pass&quot;,oneFileName);
              }
            } else {
              //对于目录文件，递归调用
              listFile.addAll(getChildrenFileList(file.getAbsolutePath()));
            }
          }
        }
      }else{
        logger.info(&quot;FilePath:{} is not Directory&quot;,dir);
      }
      return listFile;

  }



  /**
   * @param regex
   * 正则表达式字符串
   * @param str
   * 要匹配的字符串
   * @return 如果str 符合 regex的正则表达式格式,返回true, 否则返回 false;
   */
  private boolean match(String regex, String str) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(str);
    return matcher.find();
  }


  private static class ExecRunnable implements Runnable {

    public ExecRunnable(ChannelProcessor channelProcessor,
                        SourceCounter sourceCounter, boolean restart, long restartThrottle,
                        boolean logStderr, int bufferCount, long batchTimeout,
                        Charset charset, String filepath,
                        String tailing, Integer readinterval,
                        boolean startAtBeginning, boolean contextIsJson,
                        Properties prop, String fileWriteJson, Long flushTime,
                        boolean contextIsFlumeLog, String domain) {

      this.channelProcessor = channelProcessor;
      this.sourceCounter = sourceCounter;
      this.restartThrottle = restartThrottle;
      this.bufferCount = bufferCount;
      this.batchTimeout = batchTimeout;
      this.restart = restart;
      this.logStderr = logStderr;
      this.charset = charset;
      this.filepath=filepath;
      this.logfile=new File(filepath);
      this.tailing=tailing;
      if(tailing.equals(&quot;all&quot;)){
        this.isTailing=true;
      }else{
        this.isTailing = Arrays.asList( tailing.split(&quot;\\|&quot;)).contains(getDomainName(filepath));
      }
      this.readinterval=readinterval;
      this.startAtBeginning=startAtBeginning;
      this.contextIsJson=contextIsJson;
      this.prop = prop;
      this.fileWriteJson=fileWriteJson;
      this.flushTime=flushTime;
      this.contextIsFlumeLog=contextIsFlumeLog;
      this.domain=getDomain(filepath);
    }



    private final ChannelProcessor channelProcessor;
    private final SourceCounter sourceCounter;
    private volatile boolean restart;
    private final long restartThrottle;
    private final int bufferCount;
    private long batchTimeout;
    private final boolean logStderr;
    private final Charset charset;
    private SystemClock systemClock = new SystemClock();
    private Long lastPushToChannel = systemClock.currentTimeMillis();
    ScheduledExecutorService timedFlushService;
    ScheduledFuture&lt;?&gt; future;
    private String filepath;
    private boolean contextIsJson;
    private Properties prop;
    private long timepoint;
    private String fileWriteJson;
    private Long flushTime;
    private String domain;

    /**
     * 当读到文件结尾后暂停的时间间隔
     */
    private long readinterval = 500;

    /**
     * 设置日志文件
     */
    private File logfile;

    /**
     * 设置是否从头开始读
     */
    private boolean startAtBeginning = false;

    /**
     * 设置tail运行标记
     */
    private String tailing = &quot;all&quot;;
    private boolean  isTailing = false;

    private boolean contextIsFlumeLog=false;

    private static String getDomain(String filePath){
      String[] strs = filePath.split(&quot;/&quot;);
      String domain ;
      domain=strs[strs.length-3];
      if(domain==null || domain.isEmpty()){
        domain=filePath;
      }
      return domain;
    }

    @Override
    public void run() {
      Transaction tt = null;
      try {
        do {
          beginReadLog();
        } while (restart);
      }catch (Exception ex){
        logger.error(&quot;=run=&gt;&quot;,ex);
        try{
          tt=  Profiler.registerInfo(&quot;service&quot;, &quot;org.apache.flume.source.ExecTailSource.ExecRunnable.run&quot;);
          Profiler.functionError(tt, ex);
        }catch (Exception exp){
          logger.error(&quot;=run=&gt;tt error &quot;,exp);
        }
      }finally {
        if(tt!=null){
          Profiler.registerEnd(tt);
        }
      }
    }

    private void beginReadLog(){
        logger.info(&quot;=run=&gt; flume tail source run start time:&quot;+new Date().toString());
        timepoint=System.currentTimeMillis();
        Long filePointer = null;
        if (this.startAtBeginning) { //判断是否从头开始读文件
          filePointer =0L;
        } else {
          if(prop!=null || prop.contains(filepath)){

            try {
              filePointer = Long.valueOf((String) prop.get(filepath));
              logger.info(&quot;=ExecRunnable.run=&gt;filePointer get from  Properties&quot;);
            }catch (Exception ex){
              logger.error(&quot;=ExecRunnable.run=&gt;&quot;,ex);
              logger.info(&quot;=ExecRunnable.run=&gt; error filePointer get from file size&quot;);
              filePointer=null;
            }
          }
          if(filePointer ==null){
            filePointer = this.logfile.length(); //指针标识从文件的当前长度开始。
            logger.info(&quot;=ExecRunnable.run=&gt;filePointer get from file size&quot;);
          }

        }

        final List&lt;Event&gt; eventList = new ArrayList&lt;Event&gt;();

        timedFlushService = Executors.newSingleThreadScheduledExecutor(
                new ThreadFactoryBuilder().setNameFormat(
                        &quot;timedFlushExecService&quot; +
                                Thread.currentThread().getId() + &quot;-%d&quot;).build());
        RandomAccessFile randomAccessFile = null;
        try {

          randomAccessFile= new RandomAccessFile(logfile, &quot;r&quot;); //创建随机读写文件
          future = timedFlushService.scheduleWithFixedDelay(new Runnable() {
                                                              @Override
                                                              public void run() {
                                                                try {
                                                                  synchronized (eventList) {
                                                                    if(!eventList.isEmpty() &amp;&amp; timeout()) {
                                                                      flushEventBatch(eventList);
                                                                    }
                                                                  }
                                                                } catch (Exception e) {
                                                                  logger.error(&quot;Exception occured when processing event batch&quot;, e);
                                                                  if(e instanceof InterruptedException) {
                                                                    Thread.currentThread().interrupt();
                                                                  }
                                                                }
                                                              }
                                                            },
                  batchTimeout, batchTimeout, TimeUnit.MILLISECONDS);

          while (this.isTailing) {
            long fileLength = this.logfile.length();
            if (fileLength &lt; filePointer) {
              randomAccessFile = new RandomAccessFile(logfile, &quot;r&quot;);
              filePointer = 0l;
            }
            if (fileLength &gt; filePointer) {
              randomAccessFile.seek(filePointer);
              String line = randomAccessFile.readLine();
              if(line!=null){
                line = new String(line.getBytes(ExecTailSourceConfigurationConstants.CHARSET_RANDOMACCESSFILE),charset);
                line = line.replaceAll(&quot;\&quot;&quot;,&quot;\'&quot;);
              }

              while (line != null) {

                //送channal
                synchronized (eventList) {
                  sourceCounter.incrementEventReceivedCount();


                  String bodyjson = &quot;&quot;;
                  if (!contextIsJson) {
                    bodyjson = MsgBuildeJson.buildeJson(contextIsFlumeLog,line,filepath,domain);
                    if(bodyjson.indexOf(&quot;{&quot;)&gt;0){
                      bodyjson = bodyjson.substring(bodyjson.indexOf(&quot;{&quot;),bodyjson.length());
                    }
                  }else{
                    bodyjson = MsgBuildeJson.changeDomain(line.toString(),domain);
                  }

                  Event oneEvent = EventBuilder.withBody(bodyjson.getBytes(charset));
                  oneEvent.getHeaders().put(&quot;UlogDomain&quot;,domain);
                  oneEvent.getHeaders().put(&quot;topic&quot;,&quot;file_channel_topic_&quot;+domain);
                  eventList.add(oneEvent);
                  if (eventList.size() &gt;= bufferCount || timeout()) {
                    flushEventBatch(eventList);
                  }
                }

                //读下一行
                line = randomAccessFile.readLine();
                if(line!=null){
                  line = new String(line.getBytes(ExecTailSourceConfigurationConstants.CHARSET_RANDOMACCESSFILE),charset);
                  line = line.replaceAll(&quot;\&quot;&quot;,&quot;\'&quot;);
                }

                try{
                  Cat.logMetricForCount(&quot;count_file_readline_&quot;+domain);
                }catch (Exception ex){
                  logger.error(&quot;=run=&gt;count_file_readline_&quot;+domain,ex);
                }

                try {
                  Long nowfilePointer = randomAccessFile.getFilePointer();
                  if (!nowfilePointer.equals(filePointer)) {
                    filePointer = nowfilePointer;
                    if (System.currentTimeMillis() - timepoint &gt; flushTime) {
                      timepoint = System.currentTimeMillis();
                      prop.setProperty(filepath, filePointer.toString());
                      FileOutputStream fos = new FileOutputStream(fileWriteJson);
                      if (fos != null) {
                        prop.store(fos, &quot;Update '&quot; + filepath + &quot;' value&quot;);
                      }
                      fos.close();

                    }
                  }
                }catch(Exception ex){
                  ex.printStackTrace();
                }
              }

            }
            Thread.sleep(this.readinterval);
          }

          synchronized (eventList) {
            if(!eventList.isEmpty()) {
              flushEventBatch(eventList);
            }
          }

        } catch (Exception e) {
          logger.error(&quot;Failed while running filpath: &quot; + filepath, e);
          if(e instanceof InterruptedException) {
            Thread.currentThread().interrupt();
          }
        } finally {

          if(randomAccessFile!=null){
            try {
              randomAccessFile.close();
            } catch (IOException ex) {
              logger.error(&quot;Failed to close reader for ExecTail source&quot;, ex);
            }
          }

        }
        logger.info(&quot;=run=&gt; flume tail source run restart:&quot;+restart);
        if(restart) {
          logger.info(&quot;=run=&gt; flume tail source run restart time:&quot;+new Date().toString());
          logger.info(&quot;Restarting in {}ms&quot;, restartThrottle);
          try {
            Thread.sleep(restartThrottle);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          }
        } else {
          logger.info(&quot;filepath [&quot; + filepath + &quot;] exited with restart[&quot; + restart+&quot;]&quot;);
        }

    }

    private void flushEventBatch(List&lt;Event&gt; eventList){
      channelProcessor.processEventBatch(eventList);
      sourceCounter.addToEventAcceptedCount(eventList.size());
      eventList.clear();
      lastPushToChannel = systemClock.currentTimeMillis();

      try{
        Cat.logMetricForCount(&quot;count_file_flushEventBatch_&quot;+domain);
      }catch (Exception ex){
        logger.error(&quot;=run=&gt;count_file_flushEventBatch_&quot;+domain,ex);
      }
    }

    private HashMap ParseFlumeLog(String log,HashMap logMap){
      String[] strLogs = log.split(&quot;\\|&quot;);
      logMap.put(&quot;className&quot;,strLogs[0]);
      logMap.put(&quot;methodName&quot;,strLogs[1]);
      logMap.put(&quot;level&quot;,strLogs[2]);
      logMap.put(&quot;treeId&quot;,strLogs[3]);
      logMap.put(&quot;requestId&quot;,strLogs[4]);
      logMap.put(&quot;transactionId&quot;,strLogs[5]);
      return logMap;
    }

    private boolean timeout(){
      return (systemClock.currentTimeMillis() - lastPushToChannel) &gt;= batchTimeout;
    }

    private static String[] formulateShellCommand(String shell, String command) {
      String[] shellArgs = shell.split(&quot;\\s+&quot;);
      String[] result = new String[shellArgs.length + 1];
      System.arraycopy(shellArgs, 0, result, 0, shellArgs.length);
      result[shellArgs.length] = command;
      return result;
    }

    public int kill() {
      logger.info(&quot;=kill=&gt; flume tail source kill start time:&quot;+new Date().toString());
      this.tailing=&quot;no&quot;;
      synchronized (this.getClass()) {
        try {
          // Stop the Thread that flushes periodically
          if (future != null) {
            future.cancel(true);
          }

          if (timedFlushService != null) {
            timedFlushService.shutdown();
            while (!timedFlushService.isTerminated()) {
              try {
                timedFlushService.awaitTermination(500, TimeUnit.MILLISECONDS);
              } catch (InterruptedException e) {
                logger.debug(&quot;Interrupted while waiting for ExecTail executor service &quot;
                        + &quot;to stop. Just exiting.&quot;);
                Thread.currentThread().interrupt();
              }
            }
          }
          logger.info(&quot;=kill=&gt; flume tail source kill end time:&quot; + new Date().toString());
          return Integer.MIN_VALUE;
        } catch (Exception ex) {
          logger.error(&quot;=kill=&gt;&quot;, ex);
          Thread.currentThread().interrupt();
        }
      }
      logger.info(&quot;=kill=&gt; flume tail source kill end time:&quot;+new Date().toString());
      return Integer.MIN_VALUE / 2;
    }
    public void setRestart(boolean restart) {
      this.restart = restart;
    }
  }
  private static class StderrReader extends Thread {
    private BufferedReader input;
    private boolean logStderr;

    protected StderrReader(BufferedReader input, boolean logStderr) {
      this.input = input;
      this.logStderr = logStderr;
    }



    @Override
    public void run() {
      try {
        int i = 0;
        String line = null;
        while((line = input.readLine()) != null) {
          if(logStderr) {
            // There is no need to read 'line' with a charset
            // as we do not to propagate it.
            // It is in UTF-16 and would be printed in UTF-8 format.
            logger.info(&quot;StderrLogger[{}] = '{}'&quot;, ++i, line);
          }
        }
      } catch (IOException e) {
        logger.info(&quot;StderrLogger exiting&quot;, e);
      } finally {
        try {
          if(input != null) {
            input.close();
          }
        } catch (IOException ex) {
          logger.error(&quot;Failed to close stderr reader for ExecTail source&quot;, ex);
        }
      }
    }
  }
}
</span></pre><span style="font-size:18px;"><br><br></span><p><p><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/52791834'>原文链接</a>