<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; WebService学习CXF开发WebService的权限控制（二）</div><div style="color:blue" align=center>WebService学习CXF开发WebService的权限控制（二）</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US"><br></span></span></p><h1 style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">W</span><span lang="en-US">eb </span><span lang="en-US">Service</span><span lang="zh-CN">如何进行权限控制？</span></span></h1><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">解决思路：服务器端要求</span><span lang="en-US">input</span><span lang="zh-CN">消息总是携带有用户名，密码信息，如果没有用户名和密码信息，直接拒绝调用</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">解决方案：拦截器</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">为了让程序员能访问，并修改</span><span lang="en-US">CXF</span><span lang="zh-CN">框架所生成的</span><span lang="en-US">SOAP</span><span lang="zh-CN">消息，</span><span lang="en-US">CXF</span><span lang="zh-CN">提供了拦截器</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">CXF</span><span lang="zh-CN">（Celtix +XFire）说明：</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">如果不用</span><span lang="en-US">CXF</span><span lang="zh-CN">等框架，</span><span lang="en-US">SOAP</span><span lang="zh-CN">消息的生成，解析都是由程序员负责。无论是添加用户名，密码信息还是提取用户名，密码信息，都可由程序员代码完成。</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">如果使用</span><span lang="en-US">CXF</span><span lang="zh-CN">等框架，</span><span lang="en-US">SOAP</span><span lang="zh-CN">消息的生成，解析都是由</span><span lang="en-US">CXF</span><span lang="zh-CN">等框架来完成。</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in"><span style="font-family:KaiTi_GB2312;"><span style="font-size: 14pt;" lang="zh-CN">总的来说，</span><span style="font-size: 14pt;" lang="en-US">CXF</span><span style="font-size: 14pt;" lang="zh-CN">对</span><span style="font-size: 13.5pt;" lang="zh-CN">发布</span><span style="font-size: 13.5pt;" lang="en-US">WebService</span><span style="font-size: 13.5pt;" lang="zh-CN">进行了封装，简化了我们的操作。</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><h1 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">拦截器：</span></h1><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">服务端添加拦截器：</span></h2><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US"><br></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">1</span><span lang="zh-CN">，获取</span><span lang="en-US">Endpoint</span><span lang="zh-CN">的</span><span lang="en-US">publish</span><span lang="zh-CN">的方法返回值。</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">2</span><span lang="zh-CN">，调用该对象的getInInterceptors，getOutInterceptors方法来获取</span><span lang="en-US">In</span><span lang="zh-CN">，</span><span lang="en-US">Out</span><span lang="zh-CN">拦截器列表，接下来就可以添加拦截器了</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><span style="font-family:KaiTi_GB2312;"></span><pre name="code" class="java">package com.tgb.client;


import javax.xml.ws.Endpoint;

import org.apache.cxf.interceptor.LoggingInInterceptor;
import org.apache.cxf.interceptor.LoggingOutInterceptor;
import org.apache.cxf.jaxws.EndpointImpl;

import com.tgb.service.HelloWorld;
import com.tgb.service.impl.HelloWorldImpl;

public class ServerMain {

	public static void main(String[] args){
		
		HelloWorld hw=new HelloWorldImpl();
		//调用endpoint的publish方法，来发布web service
//		Endpoint.publish(&quot;http://192.168.24.215:8889/hjy&quot;,hw);
		EndpointImpl ep=(EndpointImpl)Endpoint.publish(&quot;http://192.168.24.215:8899/hjy&quot;,hw);
		
		//添加In拦截器
		ep.getInInterceptors().add(new LoggingInInterceptor());
		//添加Out拦截器
		ep.getOutInterceptors().add(new LoggingOutInterceptor());
		
		System.out.println(&quot;Web Service暴露成功&quot;);
	}
}</pre><br><p style="margin: 0in; font-size: 14pt;"><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">输出内容：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><span style="font-family:KaiTi_GB2312;"><img src="34909026020050" alt=""><br></span><p style="margin: 0in; font-size: 14pt;"><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">客户端添加拦截器：</span></h2><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">1</span><span lang="zh-CN">，添加相应的</span><span lang="en-US">CXF</span><span lang="zh-CN">的</span><span lang="en-US">jar</span><span lang="zh-CN">包</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">2</span><span lang="zh-CN">，调用</span><span lang="en-US">Client</span><span lang="en-US">Proxy</span><span lang="zh-CN">的getClient方法，调用该方法以远程</span><span lang="en-US">Web Service</span><span lang="zh-CN">的代理为参数</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">3</span><span lang="zh-CN">，调用</span><span lang="en-US">Client</span><span lang="zh-CN">对象的getInInterceptor</span><span lang="en-US">s</span><span lang="zh-CN">，getOutInterceptors方法来获取</span><span lang="en-US">In</span><span lang="zh-CN">，</span><span lang="en-US">Out</span><span lang="zh-CN">拦截器列表，接下来就可以添加拦截器了</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"></span></p><pre name="code" class="java">package hjy;

import java.util.List;

import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientProxy;
import org.apache.cxf.interceptor.LoggingInInterceptor;
import org.apache.cxf.interceptor.LoggingOutInterceptor;

import com.tgb.service.Cat;
import com.tgb.service.HelloWorld;
import com.tgb.service.User;
import com.tgb.service.impl.HelloWorldImpl;

public class ClientMain {

	public static void main(String[] args){
		HelloWorldImpl factory=new HelloWorldImpl();
		//此处返回的只是远程Web Service的代理
		HelloWorld hw=factory.getHelloWorldImplPort();
		
		Client client=ClientProxy.getClient(hw);
		client.getInInterceptors().add(new LoggingInInterceptor());
		client.getOutInterceptors().add(new LoggingOutInterceptor());
		
		System.out.println(hw.sayHi(&quot;hejingyuan&quot;));
		
		System.out.println(&quot;--------------------------&quot;);
		
		User user=new User();
		user.setId(20);
		user.setName(&quot;孙悟空&quot;);
		user.setPass(&quot;111&quot;);
		user.setAddress(&quot;花果山&quot;);
		
		List&lt;Cat&gt; cats=hw.getCatsByUser(user);
		for(Cat cat:cats){
			System.out.println(cat.getName());
		}
		
		System.out.println(&quot;--------------------------&quot;);
		
		System.out.println(hw.getAllCats().getEntry().get(0).getKey());
		System.out.println(hw.getAllCats().getEntry().get(0).getValue().getName());
		
		

	}
}</pre>&nbsp;<p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">打印内容为：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><span style="font-family:KaiTi_GB2312;"><img src="2689717457203" alt=""><br></span><p style="margin: 0in; font-size: 14pt;"><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><h1 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">自定义拦截器</span></h1><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">实现效果：当输入用户名密码时，才可以调用我们的服务。即我们需要在服务端添加输入拦截，在客户端添加输出拦截</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">自定义拦截器，需要实现</span><span lang="en-US">Interceptor</span><span lang="zh-CN">接口，实际上，我们一般会继承</span><span lang="en-US">AbstractPhaseInterceptor</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">服务端代码：</span></h2><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><span style="font-family:KaiTi_GB2312;"></span><pre name="code" class="java">package com.tgb.client;


import javax.xml.ws.Endpoint;

import org.apache.cxf.interceptor.LoggingInInterceptor;
import org.apache.cxf.interceptor.LoggingOutInterceptor;
import org.apache.cxf.jaxws.EndpointImpl;

import com.tgb.auth.AuthInterceptor;
import com.tgb.service.HelloWorld;
import com.tgb.service.impl.HelloWorldImpl;

public class ServerMain {

	public static void main(String[] args){
		
		HelloWorld hw=new HelloWorldImpl();
		//调用endpoint的publish方法，来发布web service
//		Endpoint.publish(&quot;http://192.168.24.215:8889/hjy&quot;,hw);
		EndpointImpl ep=(EndpointImpl)Endpoint.publish(&quot;http://192.168.24.215:8891/hjy&quot;,hw);
		
		//添加In拦截器,该AuthInterceptor就会负责检查用户名，密码是否正确
		ep.getInInterceptors().add(new AuthInterceptor());
		//添加Out拦截器
//		ep.getOutInterceptors().add(new LoggingOutInterceptor());
		
		System.out.println(&quot;Web Service暴露成功&quot;);
	}
}
</pre><br><p style="margin: 0in; font-size: 14pt;"><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">AuthInterceptor ：</span></h2><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"></span></p><pre name="code" class="java">package com.tgb.auth;

import java.util.List;

import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.headers.Header;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;


//通过PhaseInterceptor，可以指定拦截器在哪个阶段起作用
public class AuthInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt;{

	//由于AbstractPhaseInterceptor无无参数构造器，使用继承的方式，需要显示调用父类有参数的构造器
	public AuthInterceptor(){
		//super表示显示调用父类有参数的构造器
		//显示调用父类构造器之后，程序将不会隐式调用父类无参数的构造器
		super(Phase.PRE_INVOKE);//该拦截器将会调用之前拦截SOAP消息
	}
	//实现自己的拦截器时，需要实现handleMessage方法。
	//handleMessage方法中的形参就是被拦截到的Soap消息
	//一旦程序获取了SOAP消息，剩下的事情就可以解析SOAP消息或修改SOAP消息
	@Override
	public void handleMessage(SoapMessage msg) throws Fault {
		
		System.out.println(&quot;-------&quot;+msg);
		//从这里可以看出，我们已经拦截到了SOAP消息
		
		//得到SOAP消息所有Header
		List&lt;Header&gt; headers=msg.getHeaders();
		
		//如果没有Header
		if(headers==null||headers.size()&lt;1){
			throw new Fault(new IllegalArgumentException(&quot;根本没有Header，不能调用&quot;));						
		}
		
		//假如要求第一个Header携带了用户名，密码信息
		Header firstHeader=headers.get(0);
		Element ele=(Element)firstHeader.getObject();
		
		NodeList userIds=ele.getElementsByTagName(&quot;userId&quot;);
		NodeList userPasses=ele.getElementsByTagName(&quot;userPass&quot;);
		
		if(userIds.getLength()!=1){
			throw new Fault(new IllegalArgumentException(&quot;用户名的格式不正确！&quot;));
		}
		if(userPasses.getLength()!=1){
			throw new Fault(new IllegalArgumentException(&quot;密码的格式不正确！&quot;));
		}
		
		//得到第一个userId元素里的文本内容，以该内容作为用户名字
		String userId=userIds.item(0).getTextContent();
		String userPass=userPasses.item(0).getTextContent();
		//实际项目中，应该去查询数据库，该用户名密码是否被授权调用web service
		if(!userId.equals(&quot;hejingyuan&quot;) || !userPass.equals(&quot;hjy&quot;)){
			throw new Fault(new IllegalArgumentException(&quot;用户名密码不正确！&quot;));
		}
	}

}
</pre><br><p><p style="margin: 0in; font-size: 14pt;"><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">客户端代码：</span></h2><span style="font-family:KaiTi_GB2312;"><br></span><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"></span></p><pre name="code" class="java">package hjy;

import java.util.List;

import org.apache.cxf.endpoint.Client;
import org.apache.cxf.frontend.ClientProxy;

import com.tgb.auth.AddHeaderInterceptor;
import com.tgb.service.Cat;
import com.tgb.service.HelloWorld;
import com.tgb.service.User;
import com.tgb.service.impl.HelloWorldImpl;

public class ClientMain {

	public static void main(String[] args){
		HelloWorldImpl factory=new HelloWorldImpl();
		//此处返回的只是远程Web Service的代理
		HelloWorld hw=factory.getHelloWorldImplPort();
		
		Client client=ClientProxy.getClient(hw);
		//参数为输入的用户名，密码
		client.getOutInterceptors().add(new AddHeaderInterceptor(&quot;hejingyuan&quot;,&quot;hjy&quot;));
		
		System.out.println(hw.sayHi(&quot;hejingyuan&quot;));
		
		System.out.println(&quot;--------------------------&quot;);
		
		User user=new User();
		user.setId(20);
		user.setName(&quot;孙悟空&quot;);
		user.setPass(&quot;111&quot;);
		user.setAddress(&quot;花果山&quot;);
		
		List&lt;Cat&gt; cats=hw.getCatsByUser(user);
		for(Cat cat:cats){
			System.out.println(cat.getName());
		}
		
		System.out.println(&quot;--------------------------&quot;);
		
		System.out.println(hw.getAllCats().getEntry().get(0).getKey());
		System.out.println(hw.getAllCats().getEntry().get(0).getValue().getName());
		

	}
}</pre><br><p><h2 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">AddHeaderInterceptor：</span></h2><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"></span></p><pre name="code" class="java">package com.tgb.auth;

import java.util.List;

import javax.xml.namespace.QName;

import org.apache.cxf.binding.soap.SoapMessage;
import org.apache.cxf.headers.Header;
import org.apache.cxf.helpers.DOMUtils;
import org.apache.cxf.interceptor.Fault;
import org.apache.cxf.phase.AbstractPhaseInterceptor;
import org.apache.cxf.phase.Phase;
import org.w3c.dom.Document;
import org.w3c.dom.Element;


public class AddHeaderInterceptor extends AbstractPhaseInterceptor&lt;SoapMessage&gt;{

	private String userId;
	private String userPass;
	
	public AddHeaderInterceptor(String userId,String userPass){
		super(Phase.PREPARE_SEND);//在准备发送SOAP消息时启用该拦截器
		this.userId=userId;
		this.userPass=userPass;
	}
	@Override
	public void handleMessage(SoapMessage msg) throws Fault {
		List&lt;Header&gt; headers=msg.getHeaders();
		//创建Document对象
		Document doc=DOMUtils.createDocument();
		Element ele=doc.createElement(&quot;authHeader&quot;);
		
		//此处创建的元素应该按照服务器那边的要求
		Element idEle=doc.createElement(&quot;userId&quot;);
		idEle.setTextContent(userId);
		Element passEle=doc.createElement(&quot;userPass&quot;);
		passEle.setTextContent(userPass);
		
		ele.appendChild(idEle);
		ele.appendChild(passEle);
		
		/**
		 * 上面代码生成了一个如下XML文档片段
		 * &lt;authHeader&gt;
		 * 		&lt;userId&gt;hejingyuan&lt;/userId&gt;
		 * 		&lt;userPass&gt;hjy&lt;/userPass&gt;
		 * &lt;/authHeader&gt;
		 */
		//把ele元素包装成Header，并添加到SOAP消息的Header列表中
		headers.add(new Header(new QName(&quot;hejingyuan&quot;),ele));
	}

}</pre><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><span lang="zh-CN"><br></span></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><span lang="zh-CN">启动服务端的ServerMain的</span><span lang="en-US">main</span><span lang="zh-CN">函数，将服务发布，然后启动客户端ClientMain的</span><span lang="en-US">main</span><span lang="zh-CN">函数去访问服务端提供的服务。</span></span></p><p><p style="margin: 0in; font-size: 14pt;"><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">用户名密码错误时：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><span style="font-family:KaiTi_GB2312;"><img src="10552916026764" alt=""><br></span><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">用户名密码正确时：<br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><img src="17080765749605" alt=""><br></span></p><p style="margin: 0in; font-size: 14pt;"><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><h1 style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">总结：</span></h1><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">权限控制的实现方式为使用拦截器，对于拦截到的</span><span lang="en-US">Soap</span><span lang="zh-CN">消息进行修改。</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">SOAP</span><span lang="zh-CN">消息：</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">根元素是</span><span lang="en-US">Envolope</span></span></p><p style="margin: 0in 0in 0in 0.375in; font-size: 14pt;" lang="en-US"><span style="font-family:KaiTi_GB2312;">Header</span></p><p style="margin:0in;margin-left:.75in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">默认情况下，</span><span lang="en-US">Header</span><span lang="zh-CN">元素不是强制出现的</span></span></p><p style="margin:0in;margin-left:.75in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">Header</span><span lang="zh-CN">元素由程序员控制添加，主要用户携带一些额外的信息，比如用户名，密码信息</span></span></p><p style="margin: 0in 0in 0in 0.375in; font-size: 14pt;" lang="en-US"><span style="font-family:KaiTi_GB2312;">Body</span></p><p style="margin:0in;margin-left:.75in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">如果调用正确，</span><span lang="en-US">Body</span><span lang="zh-CN">元素的内容应该遵守</span><span lang="en-US">WSDL</span><span lang="zh-CN">所要求的格式</span></span></p><p style="margin:0in;margin-left:.75in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">如果调用错误，</span><span lang="en-US">Body</span><span lang="zh-CN">元素的内容就是</span><span lang="en-US">Fault</span><span lang="zh-CN">子元素</span></span></p><span style="font-family:KaiTi_GB2312;"><br></span><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><br></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><a target="_blank" target="_blank" href="http://download.csdn.net/detail/hejingyuan6/8945655">源码下载</a></span></p><p style="margin:0in;font-family:宋体;font-size:14.0pt"><br></p><p style="margin:0in;font-family:宋体;font-size:14.0pt"><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/47133659'>原文链接</a>