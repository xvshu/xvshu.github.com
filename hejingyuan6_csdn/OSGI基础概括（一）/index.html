<div style="color:blue" align=center>OSGI基础概括（一）</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<p><span style="font-family:KaiTi_GB2312; font-size:18px">研究了两天的OSGI，对于这两天的学习进行一个简短的总结。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1><span style="font-family:KaiTi_GB2312; font-size:18px">OSGi是什么</span></h1>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">OSGi——Open Service Gateway Initiative 字面上的意思是一个公共的服务平台。OSGi亦称做Java语言的动态模块系统，它为模块化应用的开发定义了一个<span style="background:red">基础架构</span>。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">简单说，它是是一个动态模块化框架的规范，提供了插件化、面向服务和插件扩展三大功能。这个规范体现非常重要的2点：“模块化”和“动态”。&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">OSGi容器已有多家开源实现，比如&nbsp;Knoflerfish、Equinox和Apache的Felix。我们可以通过这些容器，把应用程序劈分为多个模块单元，这样，就可以更容易地管理这些模块单元之间的交叉依赖关系。&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1><span style="font-family:KaiTi_GB2312; font-size:18px">OSGi的由来</span></h1>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:18px">从问题入手：</span></h2>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">面对现在的软件变得越来越庞大。这样，随之而来的最大挑战就是软件在设计上的越来越复杂和维护上的越来越困难。为了解决这个问题，软件架构师将软件切分成比较小的并且易于理解的多个模块。</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">软件模块化是软件架构师的主流思想。为了实现软件模块化，应运而生的就是面向对象的高级编程语言，Java是其中的典型代表。但是 Java 却不能真正的带给我们软件模块化</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">一个模块应该有以下3 个特性：</span></p>
<ul type="disc">
<li><span style="font-family:KaiTi_GB2312; font-size:18px">自包含：一个模块应该是一个业务逻辑的整体。它应该可以作为一个独立的整体被移动、安装和卸载。模块不是一个原子体，它可以包含多个更小的部分，但这些部分不能独立存在。</span></li><li><span style="font-family:KaiTi_GB2312; font-size:18px">高内聚：一个模块不应该做很多不相关的事情，它应该专注于 1 个业务逻辑的目标并尽全力实现这个目标。</span></li><li><span style="font-family:KaiTi_GB2312; font-size:18px">低耦合：一个模块不应该关注其他模块的内部实现，松散的联系允许我们去更改某个特定的模块，而不会影响到其他的模块。</span></li></ul>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h2><span style="font-family:KaiTi_GB2312; font-size:18px">那么java的问题在哪里？</span></h2>
<p><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p><span style="font-family:KaiTi_GB2312; font-size:18px"></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">1</span><span lang="zh-CN">，Java类装载器</span></span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">针对一个Jar 文件，没有对应的 Java 运行时的概念。Jar 文件只有在开发和部署的时候有意义，而在 JVM 中，所有的 Jar文件中的内容被简单地联系在一起作为一个单独的全局的列表，这就是所谓的“Classpath”。这种类加载模式，使 Jar文件在运行时是不可见的（即在运行时是看不到依赖关系的），导致的问题不能动态加载。</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">2</span><span lang="zh-CN">，类冲突</span></span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">即当类路径上存在同一个类的不同版本时，如果类加载器找到一个版本，则不再搜索加载下一个版本（现在的Jar 文件没有版本信息，这样，同一 Jar 文件的多个版本就不能同时被加载）。</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">3</span><span lang="zh-CN">，包可见性管理</span></span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">Java没有机制在不同的 Jar 文件中隐藏信息。</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">考虑下面这种场景：</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">Jar包中包含以下三个包：</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">com.boco.tongyong.kernal</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">com.boco.tongyong.service</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">com.boco.tongyong.service.impl</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">假设</span><span lang="en-US">impl和kernal包中是我们的实现，应用模块并不需要关心，我们只需要将service包暴露出来，应该如何处理？</span></span></p>
<p lang="en-US" style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">4</span><span lang="zh-CN">，jar包依赖性管理</span></span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">即无法确定jar之间的依赖关系：现有的JAR标准中缺乏对与Jar文件之间依赖关系的定义支持，因此只有在运行时间无法找到所需的类时，才会打出java.lang.ClassNotFoundException，但这通常不能有效帮助开发人员解决问题</span></p>
<p style="margin:0in 0in 0in 0.375in"><span style="font-family:KaiTi_GB2312; font-size:18px">简单解释：Jar文件没有标准信息去指明该 Jar 文件所需要的外部依赖文件列表，这样我们就不能清楚的知道，该 Jar 文件需要和其他的那些 Jar 文件一起工作。</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><br>
</span></p>
<h2 style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">应对以上问题</span></h2>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">OSGi是一个动态的Java模块（Module）系统，它规定了如何定义一个Module以及这些模块之间如何交互。每个OSGi的Java模块被称为一个bundle。每个bundle都有自己的类路径，可以精确规定哪些Java包和类可以被导出，需要导入哪些其它bundle的哪些类和包，并从而指明bundle之间的依赖关系可以指明版本信息。另外bundle可以被在运行时间安装，更新，卸载并且不影响整个应用。通过这种方式，分层的类加载机制变成了网状的类加载机制。在应用程序启动之前，OSGi就可以检测出来是否所有的依赖关系被满足，并在不满足时精确报出是哪些依赖关系没被满足。</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1 style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">那么接下来我们再具体说一下它的优点：</span></h1>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">a)&nbsp;</span><span lang="en-US">可以在不重启容器的情况下，动态地安装、卸载、启动和停止</span><span lang="zh-CN">我们</span><span lang="en-US">的应用程序中的不同模块；</span><span lang="en-US">&nbsp;</span></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">b)&nbsp;</span><span lang="zh-CN">对于应用程序中的某一特定模块，容器可以同时运行该模块的多个版本；</span><span lang="en-US">&nbsp;</span></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">c)</span><span lang="en-US"></span><span lang="zh-CN">高复用性</span></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">d</span><span lang="zh-CN">)&nbsp;OSGi</span><span lang="zh-CN">为开发嵌入式应用、移动应用、富互联网应用</span><span lang="en-US">(RIA)</span><span lang="en-US">提供了非常优秀的基础架构</span><span lang="en-US">&nbsp;</span></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1 style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="en-US">OSGI</span><span lang="zh-CN">与</span><span lang="en-US">Maven</span></span></h1>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">通过以上的陈述，大家会觉得</span><span lang="en-US">maven</span><span lang="zh-CN">也具有模块化系统的特征；那么它们又有什么关系呢？</span><span lang="en-US">maven</span><span lang="zh-CN">它只是一个编译时工具，而不是运行时框架。Maven并不是OSGi的竞争者，而是OSGi的一个补充。</span></span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1 style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">OSGi</span><span lang="zh-CN">在企业开发中的应用</span><span lang="en-US">&nbsp;</span></span></h1>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">OSGi</span><span lang="zh-CN">联盟</span><span lang="en-US">(OSGiAlliance)</span><span lang="en-US">于</span><span lang="en-US">1999</span><span lang="en-US">年</span><span lang="en-US">3</span><span lang="en-US">月开始着手制定</span><span lang="en-US">OSGi</span><span lang="en-US">规范，其主要目的就是要制定一套开放式标准，以便向局域网及其中的</span><span lang="en-US">&nbsp;</span><span lang="en-US">设备提供可管理的服务；其基本思路是，一旦您在网络设备（如服务器和嵌入式设备）上使用了</span><span lang="en-US">OSGi</span><span lang="en-US">服务平台，您就可以在网络上的任何地方管理这些设备上运</span><span lang="en-US">&nbsp;</span><span lang="en-US">行的软件组件的生命周期，可以在后台对这些组件进行安装、升级或卸载，但不需要打断该设备的正常运行。</span><span lang="en-US">&nbsp;</span><span lang="en-US">近年来，</span><span lang="en-US">OSGi</span><span lang="en-US">技术在嵌入式系统及网络设备市场得到广泛应用。现在，由于</span><span lang="en-US">Eclipse</span><span lang="en-US">的成功，</span><span lang="en-US">OSGi</span><span lang="en-US">在企业开发中逐渐成为切实可行的、较有价&#20540;的一种技术。</span></span></p>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<h1 style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">总结</span></h1>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">简单举例说明一下，</span><span lang="en-US">比如我们在开发Web应用时，我们可以把这个Web应用分为多个模块，一个模块负责视图层，另一个模块负责DAO层，第三个模块负责数据访问层，如果我们使用OSGi容器来管理这些模块之间的交叉依赖，我们就可以在不用重启该Web应用的前提下，将DAO层从速度较慢的升级到速度较快的DAO。</span></span></p>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<p style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px"><span lang="zh-CN">下篇继续：实现简单</span><span lang="en-US">demo</span></span></p>
<p lang="en-US" style="margin:0in"><span style="font-family:KaiTi_GB2312; font-size:18px">&nbsp;</span></p>
<br>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/44118053'>原文链接</a>