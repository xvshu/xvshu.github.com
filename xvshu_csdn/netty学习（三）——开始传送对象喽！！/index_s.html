<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; netty学习（三）——开始传送对象喽！！</div><div style="color:blue" align=center>netty学习（三）——开始传送对象喽！！</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 上篇博客中，我们学习了如何简单建立链接，在本篇中，我们开始利用netty传输简单的对象，做一个简单的范例：</span></p><h1><span style="font-size:18px;">1，服务端</span></h1><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 1.1 服务端</span></h2><p><span style="font-size:18px;"></span><pre code_snippet_id="1761102" snippet_file_name="blog_20160713_1_3409638" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.two;

import org.jboss.netty.bootstrap.ServerBootstrap;
import org.jboss.netty.channel.*;
import org.jboss.netty.channel.socket.nio.NioServerSocketChannelFactory;
import org.jboss.netty.handler.codec.serialization.ClassResolvers;
import org.jboss.netty.handler.codec.serialization.ObjectDecoder;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

/**
 * Netty 服务端
 * Created by xvshu on 2016/7/13.
 */
public class HelloServer {
    public static void main(String args[]) {

        // Server服务启动器

        ServerBootstrap bootstrap = new ServerBootstrap(

                new NioServerSocketChannelFactory(

                        Executors.newCachedThreadPool(),

                        Executors.newCachedThreadPool()));

        // 设置一个处理客户端消息和各种消息事件的类(Handler)

        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
            @Override
            public ChannelPipeline getPipeline()throws Exception {
                return Channels.pipeline(
                        new ObjectDecoder(ClassResolvers.cacheDisabled(this
                                .getClass().getClassLoader())),
                        new ObjectServerHandler());
            }
        });

        // 开放8000端口供客户端访问。

        bootstrap.bind(new InetSocketAddress(8000));

    }



}
</span></pre><span style="font-size:18px;"><br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span></p><p><span style="font-size:18px;"><br></span></p><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 1.2 注册事件</span></h2><p><pre code_snippet_id="1761102" snippet_file_name="blog_20160713_2_4903354" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.two;

import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

/**
 * 对象传递服务端代码
 * Created by xvshu on 2016/7/13.
 */
public class ObjectServerHandler extends SimpleChannelHandler {

    /**
     * 当接受到消息的时候触发
     */
    @Override
    public void messageReceived(ChannelHandlerContext ctx, MessageEvent e)
    throws Exception {
        Command command = (Command) e.getMessage();
        // 打印看看是不是我们刚才传过来的那个
        System.out.println(command.getActionName());
    }
}
</span></pre><span style="font-size:18px;"><br><br></span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">2，客户端</span></h1><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 2.1 客户端</span></h2><p><pre code_snippet_id="1761102" snippet_file_name="blog_20160713_3_7269905" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.two;

import org.jboss.netty.bootstrap.ClientBootstrap;
import org.jboss.netty.channel.ChannelPipeline;
import org.jboss.netty.channel.ChannelPipelineFactory;
import org.jboss.netty.channel.Channels;
import org.jboss.netty.channel.socket.nio.NioClientSocketChannelFactory;
import org.jboss.netty.handler.codec.serialization.ObjectEncoder;

import java.net.InetSocketAddress;
import java.util.concurrent.Executors;

/**
 * Netty 客户端
 * Created by xvshu on 2016/7/13.
 */
public class HelloClient {
    public static void main(String args[]) {

        // Client服务启动器

        ClientBootstrap bootstrap = new ClientBootstrap(

                new NioClientSocketChannelFactory(

                        Executors.newCachedThreadPool(),

                        Executors.newCachedThreadPool()));

        // 设置一个处理服务端消息和各种消息事件的类(Handler)
        bootstrap.setPipelineFactory(new ChannelPipelineFactory() {
            @Override
            public ChannelPipeline getPipeline()throws Exception {
                return Channels.pipeline(new ObjectEncoder(),
                        new ObjectClientHandler());
            }
        });

        // 连接到本地的8000端口的服务端

        bootstrap.connect(new InetSocketAddress(

                &quot;127.0.0.1&quot;, 8000));

    }




}
</span></pre><span style="font-size:18px;"><br><br></span></p><p><span style="font-size:18px;"><br></span></p><h2><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 2.2 注册事件</span></h2><p><pre code_snippet_id="1761102" snippet_file_name="blog_20160713_4_1588304" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.two;

import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ChannelStateEvent;
import org.jboss.netty.channel.SimpleChannelHandler;

/**
 * Created by xvshu on 2016/7/13.
 */
public class ObjectClientHandler extends SimpleChannelHandler {

    /**
     * 当绑定到服务端的时候触发，给服务端发消息。
     *
     * @author lihzh
     * @alia OneCoder
     */
    @Override
    public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) {
        // 向服务端发送Object信息
        sendObject(e.getChannel());
    }

    /**
     * 发送Object
     *
     * @param channel
     * @author lihzh
     * @alia OneCoder
     */
    private void sendObject(Channel channel) {
        Command command =new Command();
        command.setActionName(&quot;Hello action.&quot;);
        channel.write(command);
    }

}
</span></pre><span style="font-size:18px;"><br><br></span></p><p><span style="font-size:18px;"><br></span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">3，pojo对象</span></h1><p><pre code_snippet_id="1761102" snippet_file_name="blog_20160713_5_8730601" name="code" class="java"><span style="font-size:18px;">package com.xvshu.test.two;

import java.io.Serializable;

/**
 * Created by xvshu on 2016/7/13.
 */
public class Command implements Serializable {

    private static final long serialVersionUID = 7590999461767050471L;

    private String actionName;

    public String getActionName() {
        return actionName;
    }

    public void setActionName(String actionName) {
        this.actionName = actionName;
    }
}
</span></pre><span style="font-size:18px;"><br>&nbsp; &nbsp; &nbsp; &nbsp; 启动与上篇博客一致，结果我们发现，在服务端我们接收到了对象，并转换成功，我们到此已经可以简单使用netty进行通信了！</span></p><p><span style="font-size:18px;"><br></span></p><h1><span style="font-size:18px;">总结</span></h1><p><span style="font-size:18px;">&nbsp; &nbsp; &nbsp; &nbsp; 在从简单到复杂的过程中，我们对netty的接口几乎并没有什么歧义，这固然是经验使然，也是netty接口设计的合理， 我们完全可以见词生意，接口单词的选择，对一个软件的成败也是非常关键的，毕竟这是程序员接触到的UI，而在程序设计上UI一直就是我们力度下的比较大的部分。</span></p><p><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/51901535'>原文链接</a>