<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; MongoDB之索引</div><div style="color:blue" align=center>MongoDB之索引</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<div id="cnblogs_post_body" style="margin-bottom: 20px; word-break: break-word; font-family: Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif; font-variant-ligatures: normal; line-height: 18px; orphans: 2; widows: 2;"><p style="margin: 10px auto;"><span style="color: rgb(128, 0, 128); font-size: 16px;">一、索引基础：</span><br>&nbsp;&nbsp; &nbsp;MongoDB的索引几乎与传统的关系型数据库一模一样，这其中也包括一些基本的优化技巧。下面是创建索引的命令：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;username&quot;:1})<br>&nbsp;&nbsp; &nbsp;可以通过下面的名称查看索引是否已经成功建立：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.getIndexes()<br>&nbsp;&nbsp; &nbsp;删除索引的命令是：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.dropIndex({&quot;username&quot;:1})<br>&nbsp;&nbsp; &nbsp;在MongoDB中，我们同样可以创建复合索引，如：<br>&nbsp;&nbsp; &nbsp;<em><span style="color: rgb(0, 128, 0);">-- 数字1表示username键的索引按升序存储，-1表示age键的索引按照降序方式存储。</span></em><br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;username&quot;:1, &quot;age&quot;:-1})<br>&nbsp;&nbsp; &nbsp;该索引被创建后，基于username和age的查询将会用到该索引，或者是基于username的查询也会用到该索引，但是只是基于age的查询将不会用到该复合索引。因此可以说，如果想用到复合索引，必须在查询条件中包含复合索引中的前N个索引列。然而如果查询条件中的键值顺序和复合索引中的创建顺序不一致的话，MongoDB可以智能的帮助我们调整该顺序，以便使复合索引可以为查询所用。如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.find({&quot;age&quot;: 30, &quot;username&quot;: &quot;stephen&quot;})<br>&nbsp;&nbsp; &nbsp;对于上面示例中的查询条件，MongoDB在检索之前将会动态的调整查询条件文档的顺序，以使该查询可以用到刚刚创建的复合索引。<br>&nbsp;&nbsp; &nbsp;我们可以为内嵌文档创建索引，其规则和普通文档没有任何差别，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;comments.date&quot;:1})<br>&nbsp;&nbsp; &nbsp;对于上面创建的索引，MongoDB都会根据索引的keyname和索引方向为新创建的索引自动分配一个索引名，下面的命令可以在创建索引时为其指定索引名，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;username&quot;:1},{&quot;name&quot;:&quot;testindex&quot;})&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<span style="color:#990000;">随着集合的增长，需要针对查询中大量的排序做索引。如果没有对索引的键调用sort，MongoDB需要将所有数据提取到内存并排序。因此在做无索引排序时，如果数据量过大以致无法在内存中进行排序，此时MongoDB将会报错。</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="font-size: 16px; color: rgb(128, 0, 128);">二、唯一索引：</span><br>&nbsp;&nbsp; &nbsp;在缺省情况下创建的索引均不是唯一索引。下面的示例将创建唯一索引，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;userid&quot;:1},{&quot;unique&quot;:true})<br>&nbsp;&nbsp; &nbsp;如果再次插入userid重复的文档时，MongoDB将报错，以提示插入重复键，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid&quot;:5})<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid&quot;:5})<br>&nbsp;&nbsp; &nbsp;E11000 duplicate key error index: test.test.$userid_1&nbsp; dup key: { : 5.0 }&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;如果插入的文档中不包含userid键，那么该文档中该键的值为null，如果多次插入类似的文档，MongoDB将会报出同样的错误，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid1&quot;:5})<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid1&quot;:5})<br>&nbsp;&nbsp; &nbsp;E11000 duplicate key error index: test.test.$userid_1&nbsp; dup key: { : null }&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;如果在创建唯一索引时已经存在了重复项，我们可以通过下面的命令帮助我们在创建唯一索引时消除重复文档，仅保留发现的第一个文档，如：<br>&nbsp;&nbsp; &nbsp;<em><span style="color: rgb(0, 128, 0);">--先删除刚刚创建的唯一索引。</span></em><br>&nbsp;&nbsp; &nbsp;&gt; db.test.dropIndex({&quot;userid&quot;:1})&nbsp;<br>&nbsp;&nbsp; &nbsp;<em><span style="color: rgb(0, 128, 0);">--插入测试数据，以保证集合中有重复键存在。</span></em><br>&nbsp;&nbsp; &nbsp;&gt; db.test.remove()<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid&quot;:5})<br>&nbsp;&nbsp; &nbsp;&gt; db.test.insert({&quot;userid&quot;:5})&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<em><span style="color: rgb(0, 128, 0);">--创建唯一索引，并消除重复数据。</span></em><br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;userid&quot;:1},{&quot;unique&quot;:true,&quot;dropDups&quot;:true})&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<em><span style="color: rgb(0, 128, 0);">--查询结果确认，重复的键确实在创建索引时已经被删除。</span></em><br>&nbsp;&nbsp; &nbsp;&gt; db.test.find()<br>&nbsp;&nbsp; &nbsp;{ &quot;_id&quot; : ObjectId(&quot;4fe823c180144abd15acd52e&quot;), &quot;userid&quot; : 5 }&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;我们同样可以创建复合唯一索引，即保证复合键值唯一即可。如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;userid&quot;:1,&quot;age&quot;:1},{&quot;unique&quot;:true})&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="color: rgb(128, 0, 128); font-size: 16px;">三、使用explain：</span><br>&nbsp;&nbsp; &nbsp;explain是非常有用的工具，会帮助你获得查询方面诸多有用的信息。只要对游标调用该方法，就可以得到查询细节。explain会返回一个文档，而不是游标本身。如：<br>&nbsp;&nbsp; &nbsp;&gt; db.test.find().explain()<br>&nbsp;&nbsp; &nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;cursor&quot; : &quot;BasicCursor&quot;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;nscanned&quot; : 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;nscannedObjects&quot; : 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;n&quot; : 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;millis&quot; : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;nYields&quot; : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;nChunkSkips&quot; : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;isMultiKey&quot; : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;indexOnly&quot; : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &quot;indexBounds&quot; : {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;explain会返回查询使用的索引情况，耗时和扫描文档数的统计信息。<br><em><span style="color: rgb(0, 128, 0);">&nbsp;&nbsp; &nbsp;&quot;cursor&quot;:&quot;BasicCursor&quot;表示没有使用索引。</span><br><span style="color: rgb(0, 128, 0);">&nbsp;&nbsp; &nbsp;&quot;nscanned&quot;:1 表示查询了多少个文档。</span><br><span style="color: rgb(0, 128, 0);">&nbsp;&nbsp; &nbsp;&quot;n&quot;:1 表示返回的文档数量。</span><br><span style="color: rgb(0, 128, 0);">&nbsp;&nbsp; &nbsp;&quot;millis&quot;:0 表示整个查询的耗时。</span></em><br>&nbsp;&nbsp;&nbsp;&nbsp;<br><span style="color: rgb(128, 0, 128); font-size: 16px;">四、索引管理：</span><br>&nbsp;&nbsp; &nbsp;system.indexes集合中包含了每个索引的详细信息，因此可以通过下面的命令查询已经存在的索引，如：<br>&nbsp;&nbsp; &nbsp;&gt; db.system.indexes.find()<br>&nbsp;&nbsp; &nbsp;如果在为已有数据的文档创建索引时，可以执行下面的命令，以使MongoDB在后台创建索引，这样的创建时就不会阻塞其他操作。但是相比而言，以阻塞方式创建索引，会使整个创建过程效率更高，但是在创建时MongoDB将无法接收其他的操作。<br>&nbsp;&nbsp; &nbsp;&gt; db.test.ensureIndex({&quot;username&quot;:1},{&quot;background&quot;:true})</p><div><br></div><div><br></div></div><div class="clear" style="clear: both; font-family: Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif; font-variant-ligatures: normal; line-height: 18px; orphans: 2; widows: 2;"></div><div id="blog_post_info_block" style="margin-top: 20px; font-family: Verdana, 'Lucida Grande', Arial, Helvetica, sans-serif; font-variant-ligatures: normal; line-height: 18px; orphans: 2; widows: 2;"></div>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/52471361'>原文链接</a>