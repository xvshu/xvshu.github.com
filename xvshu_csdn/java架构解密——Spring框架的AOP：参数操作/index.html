<div style="color:blue" align=center>java架构解密——Spring框架的AOP：参数操作</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">

<span style="font-size:18px">&nbsp; &nbsp; &nbsp; &nbsp; 在最近的研究中，发现aspectj 的拦截非常实用，也封装了N多方法方便我们调用，正好我们在对工作流的业务进行封装，发现虽然有些需求没有实现但是和我们的封装已经可以在很高的层面上吻合，给大家分享<br>
<br>
<br>
</span>
<h1><span style="font-size:18px">获取目标方法的信息</span></h1>
<p><span style="font-size:18px">&nbsp; &nbsp;&nbsp;</span></p>
<p><span style="font-size:18px">访问目标方法最简单的做法是定义增强处理方法时，将第一个参数定义为JoinPoint类型，JoinPoint是SpringAoP中，只支持Method Execution （方法执行）的Joinpoint,对于类型中的属性，我们可以通过对setter，getter方法的拦截从而达到相同的效果。</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px">JoinPoint里包含了如下几个常用的方法：</span></p>
<span style="font-size:18px">Object[] getArgs：返回目标方法的参数<br>
Signature getSignature：返回目标方法的签名<br>
Object getTarget：返回被织入增强处理的目标对象<br>
Object getThis：返回AOP框架为目标对象生成的代理对象<br>
注意：当使用@Around处理时，我们需要将第一个参数定义为ProceedingJoinPoint类型，该类是JoinPoint的子类。<br>
<br>
&nbsp; &nbsp; &nbsp; &nbsp; 下面的切面类（依然放在com.abc.advice包中）中定义了Before、Around、AfterReturning和After 4中增强处理，并分别在4种增强处理中访问被织入增强处理的目标方法、目标方法的参数和被织入增强处理的目标对象等：<br>
<br>
<br>
</span><pre code_snippet_id="647057" snippet_file_name="blog_20150418_1_4635080" name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;package com.abc.advice;
 
import java.util.Arrays;
 
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
 
@Aspect
public class AdviceTest {
    @Around(&quot;execution(* com.abc.service.*.many*(..))&quot;)
    public Object process(ProceedingJoinPoint point) throws Throwable {
        System.out.println(&quot;@Around：执行目标方法之前...&quot;);
        //访问目标方法的参数：
        Object[] args = point.getArgs();
        if (args != null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0].getClass() == String.class) {
            args[0] = &quot;改变后的参数1&quot;;
        }
        //用改变后的参数执行目标方法
        Object returnValue = point.proceed(args);
        System.out.println(&quot;@Around：执行目标方法之后...&quot;);
        System.out.println(&quot;@Around：被织入的目标对象为：&quot; + point.getTarget());
        return &quot;原返回值：&quot; + returnValue + &quot;，这是返回结果的后缀&quot;;
    }
     
    @Before(&quot;execution(* com.abc.service.*.many*(..))&quot;)
    public void permissionCheck(JoinPoint point) {
        System.out.println(&quot;@Before：模拟权限检查...&quot;);
        System.out.println(&quot;@Before：目标方法为：&quot; + 
                point.getSignature().getDeclaringTypeName() + 
                &quot;.&quot; + point.getSignature().getName());
        System.out.println(&quot;@Before：参数为：&quot; + Arrays.toString(point.getArgs()));
        System.out.println(&quot;@Before：被织入的目标对象为：&quot; + point.getTarget());
    }
     
    @AfterReturning(pointcut=&quot;execution(* com.abc.service.*.many*(..))&quot;, 
        returning=&quot;returnValue&quot;)
    public void log(JoinPoint point, Object returnValue) {
        System.out.println(&quot;@AfterReturning：模拟日志记录功能...&quot;);
        System.out.println(&quot;@AfterReturning：目标方法为：&quot; + 
                point.getSignature().getDeclaringTypeName() + 
                &quot;.&quot; + point.getSignature().getName());
        System.out.println(&quot;@AfterReturning：参数为：&quot; + 
                Arrays.toString(point.getArgs()));
        System.out.println(&quot;@AfterReturning：返回值为：&quot; + returnValue);
        System.out.println(&quot;@AfterReturning：被织入的目标对象为：&quot; + point.getTarget());
         
    }
     
    @After(&quot;execution(* com.abc.service.*.many*(..))&quot;)
    public void releaseResource(JoinPoint point) {
        System.out.println(&quot;@After：模拟释放资源...&quot;);
        System.out.println(&quot;@After：目标方法为：&quot; + 
                point.getSignature().getDeclaringTypeName() + 
                &quot;.&quot; + point.getSignature().getName());
        System.out.println(&quot;@After：参数为：&quot; + Arrays.toString(point.getArgs()));
        System.out.println(&quot;@After：被织入的目标对象为：&quot; + point.getTarget());
    }
}&lt;/span&gt;</pre><span style="font-size:18px"><br>
在AdviceManager类中增加以下内容：<br>
<br>
</span>
<p><pre code_snippet_id="647057" snippet_file_name="blog_20150418_2_5742967" name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;//将被AdviceTest的各种方法匹配
public String manyAdvices(String param1, String param2) {
    System.out.println(&quot;方法：manyAdvices&quot;);
    return param1 + &quot; 、&quot; + param2;
}
&lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
</span></p>
<p><span style="font-size:18px">&nbsp;在com.abc.main.AOPTest中加入方法的调用，触发切点：</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<pre code_snippet_id="647057" snippet_file_name="blog_20150418_3_7331597" name="code" class="java">&lt;span style=&quot;font-size:18px;&quot;&gt;String result = manager.manyAdvices(&quot;aa&quot;, &quot;bb&quot;);
System.out.println(&quot;Test方法中调用切点方法的返回值：&quot; + result);&lt;/span&gt;</pre><span style="font-size:18px"><br>
<br>
&nbsp; &nbsp; 下面是执行结果：<br>
<br>
</span>
<p><pre code_snippet_id="647057" snippet_file_name="blog_20150418_4_5332177" name="code" class="plain">&lt;span style=&quot;font-size:18px;&quot;&gt;@Around：执行目标方法之前...
@Before：模拟权限检查...
@Before：目标方法为：com.abc.service.AdviceManager.manyAdvices
@Before：参数为：[改变后的参数1, bb]
@Before：被织入的目标对象为：com.abc.service.AdviceManager@1dfc617e
方法：manyAdvices
@Around：执行目标方法之后...
@Around：被织入的目标对象为：com.abc.service.AdviceManager@1dfc617e
@After：模拟释放资源...
@After：目标方法为：com.abc.service.AdviceManager.manyAdvices
@After：参数为：[改变后的参数1, bb]
@After：被织入的目标对象为：com.abc.service.AdviceManager@1dfc617e
@AfterReturning：模拟日志记录功能...
@AfterReturning：目标方法为：com.abc.service.AdviceManager.manyAdvices
@AfterReturning：参数为：[改变后的参数1, bb]
@AfterReturning：返回值为：原返回值：改变后的参数1 、 bb，这是返回结果的后缀
@AfterReturning：被织入的目标对象为：com.abc.service.AdviceManager@1dfc617e&lt;/span&gt;</pre><span style="font-size:18px"><br>
&nbsp;从结果中可以看出：在任何一个织入的增强处理中，都可以获取目标方法的信息。</span></p>
<p><span style="font-size:18px"><br>
</span></p>
<p><span style="font-size:18px">缺憾：不能获取到方法体中的局部变量！</span></p>
<span style="font-size:18px"><br>
</span>
<h1><span style="font-size:18px">总结：</span></h1>
<p><span style="font-size:18px">世上无难事，只怕有心人！在学习和提升的过程中，我们对于事情的认识往往取决于我们对事物的第一印象！所以我们在想问题的时候，是不是可以换一个角度考虑问题呢？</span></p>
<p><span style="font-size:18px">以前的角度：这个问题能不能解决？不能解决怎门办？我改怎么处理？</span></p>
<p><span style="font-size:18px">现在的角度：这个问题肯定能解决？怎么去解决？该借助哪方的力量呢？</span></p>
<p><span style="font-size:18px">这两种不同的角度，形成不同的两种循环：第一种是，担心，解决，侥幸，担心，不能解决，放弃，放弃！第二种是信心，解决，挑战，信息，解决，成功！对比下，发现，我们是不是都应该进入正能量的循环！</span></p>
<span style="font-size:18px"><br>
</span><br>
   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/xvshu/article/details/45112675'>原文链接</a>