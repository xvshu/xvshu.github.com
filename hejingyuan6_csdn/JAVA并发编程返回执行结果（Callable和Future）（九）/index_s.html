<div class="articleLocationOnion"><a href='../../index.html'>首页: </a> &gt; <a href='../index_s.html'>未分类</a> &gt; JAVA并发编程返回执行结果（Callable和Future）（九）</div><div style="color:blue" align=center>JAVA并发编程返回执行结果（Callable和Future）（九）</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp; &nbsp;启动一个线程不论使用Thread或者Runnable的时候，都是没有返回结果的。也就是说Thread和Runnable的run()方法必须没有返回值。</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp; &nbsp;public void run(){}</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">解决方案：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">Callable</span><span lang="zh-CN">和</span><span lang="en-US">Future</span><span lang="zh-CN">，一个产生结果，一个拿到结果。</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">简单的来一个实例</span><span lang="en-US">demo</span><span lang="zh-CN">帮助我们理解：</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><p style="margin:0in;font-size:14.0pt"><span lang="zh-CN"><span style="font-family:KaiTi_GB2312;"></span></span></p><pre name="code" class="java">public class CallableAndFuture {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		//单一线程的线程池
		ExecutorService threadPool =  Executors.newSingleThreadExecutor();
		Future&lt;String&gt; future =
			threadPool.submit(
				new Callable&lt;String&gt;() {
					public String call() throws Exception {
						Thread.sleep(2000);
						return &quot;hello&quot;;
					};
				}
		);
		System.out.println(&quot;等待结果&quot;);
		try {
			System.out.println(&quot;拿到结果&quot; + future.get());
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	

}</pre><br><p><p style="margin:0in;font-size:14.0pt"><span lang="zh-CN"><span style="font-family:KaiTi_GB2312;"></span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">执行结果：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">等待结果</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">拿到结果hello<span style="font-size: 14pt;">&nbsp;</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">使用场景：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">假设有一个很耗时的返回值需要计算，并且这个返回值不是立刻需要的话，那么就可以使用以上这种方式，用另一个线程去计算返回值，而当前线程在使用这个返回值之前可以做其它的操作，等到需要这个返回值时，再通过Future得到！</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">说明：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;">Future<span lang="zh-CN">取得的结果类型和</span><span lang="en-US">Callable</span><span lang="zh-CN">返回的结果类型必须一致，这是通过泛型来实现的</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">Callable</span><span lang="zh-CN">要采用</span><span lang="en-US">Executor</span><span lang="en-US">Service</span><span lang="zh-CN">的</span><span lang="en-US">submit</span><span lang="zh-CN">方法提交，返回为</span><span lang="en-US">future</span><span lang="zh-CN">对象</span></span></p><p style="margin: 0in; font-size: 14pt;">&nbsp;</p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">CompletionService</span><span lang="zh-CN">用于提交一组</span><span lang="en-US">Callable</span><span lang="zh-CN">任务，其</span><span lang="en-US">take</span><span lang="zh-CN">方法返回已完成的一个</span><span lang="en-US">Callable</span><span lang="zh-CN">任务对应的</span><span lang="en-US">Future</span><span lang="zh-CN">对象</span></span></p><p style="margin: 0in 0in 0in 0.375in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">好比我同时种了几块地的麦子，然后就等待收割，收割时，哪块先成熟，则先收割哪块</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">下面我们来针对</span><span lang="en-US">CompletionService</span><span lang="zh-CN">看一个小</span><span lang="en-US">demo</span></span></p><p style="margin:0in;font-size:14.0pt"><span lang="en-US"><br></span></p><pre name="code" class="java">public class CallableAndFuture {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		
		ExecutorService threadPool2 =  Executors.newFixedThreadPool(10);
		CompletionService&lt;Integer&gt; completionService = new ExecutorCompletionService&lt;Integer&gt;(threadPool2);
		for(int i=1;i&lt;=10;i++){
			final int seq = i;
			completionService.submit(new Callable&lt;Integer&gt;() {
				@Override
				public Integer call() throws Exception {
					Thread.sleep(new Random().nextInt(5000));
					return seq;
				}
			});
		}
		for(int i=0;i&lt;10;i++){
			try {
				System.out.println(
						completionService.take().get());
			} catch (InterruptedException e) {
				e.printStackTrace();
			} catch (ExecutionException e) {
				e.printStackTrace();
			}
		}
	}
	
}</pre><br><p style="margin:0in;font-size:14.0pt"><span lang="zh-CN"></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">执行结果：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">8</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">6</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">5</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">7</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">2</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">1</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">3</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">10</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">9</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">4</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">总结：</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;">&nbsp;</span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span lang="zh-CN">对于多线程执行返回结果这种需求在实际应用中还是很少见的，此文只是作为了解学习。</span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><p style="margin: 0in; font-size: 14pt;"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><br>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/47065629'>原文链接</a>