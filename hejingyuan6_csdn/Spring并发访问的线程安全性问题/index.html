<div style="color:blue" align=center>Spring并发访问的线程安全性问题</div><br><div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">&nbsp;&nbsp;&nbsp; 首先对于Spring的IOC来说，对象是由Spring来帮我们管理，也就是在Spring启动的时候，在Spring容器中，由Spring给我们创建的，Spring会帮我们维护，一般都是单例的，也就是一个对象。</span></p><p><br></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">spring生成对象默认是单例的。通过scope属性可以更改为多例。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">第一部分：验证Spring生成对象默认是单例的。</span></h1><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><span style="font-family:KaiTi_GB2312;font-size:18px;">    下面我们来一个网上的例子验证一下：</span><p><pre name="code" class="html">&lt;bean id=&quot;singleton&quot; class=&quot;java.util.Date&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;
&lt;bean id=&quot;prototype&quot; class=&quot;java.util.Date&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</pre><pre name="code" class="java">package test; 
import java.util.Date;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import com.opensymphony.xwork2.ActionContext;

public class TestScope {

    public static void main(String[] args) {

       ApplicationContext context=new ClassPathXmlApplicationContext(&quot;applicationContext-web.xml&quot;);

       Date s1=(Date)context.getBean(&quot;singleton&quot;);

       Date p1=(Date)context.getBean(&quot;prototype&quot;);

       Date s2=(Date)context.getBean(&quot;singleton&quot;);

       Date p2=(Date)context.getBean(&quot;prototype&quot;);
    
       System.out.println(&quot;单例：&quot;+(s1==s2));

       System.out.println(&quot;非单例：&quot;+(p1==p2));

    }


}</pre><span style="font-family:KaiTi_GB2312;font-size:18px;"><br>输出结果:</span><p><p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">结果</span></p><p align="left"><span style="font-family:KaiTi_GB2312;font-size:18px;">单例：true</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">非单例：false</span></p><br><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">注：复合数据类型的“==</span><span lang="en-US">&nbsp;”</span><span lang="zh-CN">对比的是内存中存放的地址，所以此处我们采用“==”去对比</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="en-US">因为object</span><span lang="zh-CN">中的</span><span lang="en-US">equals</span><span lang="zh-CN">初始行为是比较内存中的地址，但在一些类库中被覆盖掉了如（</span><span lang="en-US">String</span><span lang="zh-CN">，</span><span lang="en-US">Integer</span><span lang="zh-CN">，</span><span lang="en-US">Date</span><span lang="zh-CN">等）</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><h1 style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">第二部分：<span style="font-family:KaiTi_GB2312;"><span lang="zh-CN">SpringMVC和Struts2中是并发访问否会存在线程安全问题。</span></span><br></span></span></h1><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">对于使用过SpringMVC和Struts2的人来说，大家都知道SpringMVC是基于方法的拦截，而Struts2是基于类的拦截。</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><span><span><strong>        </strong>        对于Struts2来说，因为每次处理一个请求，struts就会实例化一个对象；这样就不会有线程安全的问题了<span style="color:#444444;">;</span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><span><span><span style="color:#444444;">而Spring的controller默认是Singleton的，这意味着每一个request过来，系统都会用原有的instance去处理，这样导致两个结果：</span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><span><span></span></span></span><span style="font-family:KaiTi_GB2312;font-size:18px;color:#444444;line-height:28px"><span style="color:#444444;line-height:28px">一是我们不用每次创建Controller，二是减少了对象创建和垃圾收集的时间;由于只有一个Controller的instance，当多个线程调用它的时候，它里面的instance变量就不是线程安全的了，会发生窜数据的问题。</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;color:#444444;line-height:28px"><span style="color:#444444;line-height:28px"></span><br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;color:#444444;line-height:28px">当然大多数情况下，我们根本不需要考虑线程安全的问题，比如dao,service等，除非在bean中声明了实例变量。因此，我们在使用spring mvc 的contrller时，应避免在controller中定义实例变量。&nbsp;</span><span style="font-family:KaiTi_GB2312;font-size:18px;"><br style="line-height: 28px; color: rgb(68, 68, 68); font-size: 16px;"><span style="color:#444444;font-size:16px; line-height:28px">如：</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><span style="color:#444444;font-size:16px; line-height:28px"></span></span></p><pre name="code" class="java">public class Controller extends AbstractCommandController {  
    protected Company company;
    protected ModelAndView handle(HttpServletRequest request,HttpServletResponse response,Object command,BindException errors) throws Exception {
        company = ................;         
     }           
 }  </pre><br><p><span style="font-family:KaiTi_GB2312;font-size:18px;">解决方案：</span><p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;color:#444444;line-height:28px">有几种解决方法：</span><span style="font-family:KaiTi_GB2312;font-size:18px;"><br style="line-height: 28px; color: rgb(68, 68, 68); font-size: 16px;"><span style="color:#444444;font-size:16px; line-height:28px">1、在Controller中使用ThreadLocal变量</span><br style="line-height: 28px; color: rgb(68, 68, 68); font-size: 16px;"><span style="color:#444444;font-size:16px; line-height:28px">2、在spring配置文件Controller中声明 scope=&quot;prototype&quot;，每次都创建新的controller</span><br style="line-height: 28px; color: rgb(68, 68, 68); font-size: 16px;"><span style="color:#444444;font-size:16px; line-height:28px">所在在使用spring开发web 时要注意，默认Controller、Dao、Service都是单例的。</span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><span style="color:#444444;font-size:16px; line-height:28px"><br></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">例如：</span></p><p style="margin:0in;font-size:14.0pt"><pre name="code" class="java">@Controller
@RequestMapping(&quot;/fui&quot;)
public class FuiController extends SpringController {
//这么定义的话就是单例

@Controller
@Scope(&quot;prototype&quot;)
@RequestMapping(&quot;/fui&quot;)
public class FuiController extends SpringController {
//每次都创建</pre><p><br></p><p><h1 style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">第三部分：<span style="font-family:KaiTi_GB2312;font-size:18px;">springMVC与struts2的区别</span>。</span></h1><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">下面是从网络上摘抄的一段对比，大家可以看看</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><a target="_blank" target="_blank" href="http://www.cnblogs.com/liuling/archive/2013/02/07/sdfasdf.html">点击打开链接</a></span><br></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">1. 机制：spring mvc的入口是servlet，而struts2是filter，这样就导致了二者的机制不同。 <br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">2. 性能：spring会稍微比struts快。spring mvc是基于方法的设计，而sturts是基于类，每次发一次请求都会实例一个action，每个action都会被注入属性，而spring基于方法，粒度更细，但要小心把握像在servlet控制数据一样。spring3 mvc是方法级别的拦截，拦截到方法后根据参数上的注解，把request数据注入进去，在spring3 mvc中，一个方法对应一个request上下文。而struts2框架是类级别的拦截，每次来了请求就创建一个Action，然后调用setter getter方法把request中的数据注入；struts2实际上是通过setter getter方法与request打交道的；struts2中，一个Action对象对应一个request上下文。 <br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">3. 参数传递：struts是在接受参数的时候，可以用属性来接受参数，这就说明参数是让多个方法共享的。</span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br> </span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">4. 设计思想上：struts更加符合oop的编程思想， spring就比较谨慎，在servlet上扩展。 <br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">5. intercepter的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。 <br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p><span style="font-family:KaiTi_GB2312;font-size:18px;">6. 另外，spring3 mvc的验证也是一个亮点，支持JSR303，处理ajax的请求更是方便，只需一个注解@ResponseBody ，然后直接返回响应文本即可。 </span></p><p style="margin:0in;font-size:14.0pt"><br></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">总结:</span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;"><br></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;font-size:18px;">这样也说明了SpringMVC还有Servlet都是方法的线程安全，所以在类方法声明的私有或者公有变量不是线程安全的，而struts2的确实是线程安全的。</span></p><p style="margin:0in;font-size:14.0pt"><br></p><h1><span style="font-family:KaiTi_GB2312;font-size:18px;">第四部分：</span><span style="font-size:18px;"><span style="font-family:KaiTi_GB2312;">那么对于Struts2+Spring来管理注入的时候呢？</span></span><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span></span></span></span></span></h1><br><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;">Struts2它是多实例的，对于每个请求都会生成1个实例，spring默认是单实例的（下面针对Struts与Spring集成的两种方式分别来介绍<a target="_blank" target="_blank" href="http://www.cnblogs.com/taoxiaoji/archive/2011/03/12/Two_ways_to_integrate_Struts2_and_Spring.html">struts2和spring的两种整合方式</a>）</span></span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;">一：对于无Spring插件（Struts2-spring-plugin-XXX.jar）的整合方式，需要在spring的action Bean中加业务逻辑控制器类配scope=&quot;prototype&quot;。</span></span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;"></span></span></span></span></span></p><pre name="code" class="java">&lt;bean id=&quot;user&quot; class=&quot;modle.User&quot; scope=&quot;prototype&quot;&gt;&lt;/bean&gt;</pre><br><p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;">二<span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;">：</span></span></span></span></span>对于有Spring插件（Struts2-spring-plugin-XXX.jar）的整合方式：反编译StrutsSpringObjectFactory以及相关的代码才发现，如果在struts action的配置文件中&lt;action name=&quot;..&quot; class=&quot;..&quot;/&gt;中class写的如果是完整的包名和类名的话就是struts创建action对象，也就是多实例的；</span></span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;"><br></span></span></span></span></span></p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><span><span><span style="font-size:18px;">总结：如果是spring配置文件中的 bean的名字的话就是spring创建，那么单实例还是多实例就由spring的action Bean中的业务逻辑控制器类是否配置为scope=”prototype”，有就是多实例的，没有就是单实例的，顺序是先从spring中找，找不到再从struts配置文件中找。</span><br></span></span></span></span></p><span style="font-family:KaiTi_GB2312;font-size:18px;"><span></span></span><br><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"></span></span><p><p style="margin:0in;font-size:14.0pt"><span style="font-family:KaiTi_GB2312;"><span lang="zh-CN"><br></span></span></p><br><p><br></p>   
</div><div class="ArcitleLink"><a href='http://blog.csdn.net/hejingyuan6/article/details/50363647'>原文链接</a>